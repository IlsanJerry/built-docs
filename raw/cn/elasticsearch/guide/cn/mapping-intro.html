<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">映射
        | Elasticsearch: 权威指南
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: 权威指南" /><link rel="up" href="mapping-analysis.html" title="映射和分析" /><link rel="prev" href="analysis-intro.html" title="分析与分析器" /><link rel="next" href="complex-core-fields.html" title="复杂核心域类型" /><meta xmlns="" name="description" content="有关如何使用 Elasticsearch、Kibana、Logstash、Beats、X-Pack、Elastic Cloud、Elasticsearch for Apache Hadoop 及我们各种语言的客户端的文档。" /><meta xmlns="" name="DC.type" content="Learn/Docs/Elasticsearch/Definitive Guide" /><meta xmlns="" name="DC.subject" content="Elasticsearch" /><meta xmlns="" name="DC.identifier" content="cn" /></head><body><div xmlns="" class="page_header"><b>请注意:</b><br/>本书基于 Elasticsearch 2.x 版本，有些内容可能已经过时。
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: 权威指南</a></span> » <span class="breadcrumb-link"><a href="getting-started.html">基础入门</a></span> » <span class="breadcrumb-link"><a href="mapping-analysis.html">映射和分析</a></span> » <span class="breadcrumb-node">映射</span></div><div xmlns="" class="navheader"><span class="prev"><a href="analysis-intro.html">
              « 
              分析与分析器</a>
           
        </span><span class="next">
           
          <a href="complex-core-fields.html">复杂核心域类型
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-intro"></a>映射<a xmlns="" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide/edit/cn/052_Mapping_Analysis/45_Mapping.asciidoc" class="edit_me" title="在 GitHub 上编辑本页" rel="nofollow">编辑</a></h2></div></div></div><p>为了能够将时间域视为时间，数字域视为数字，字符串域视为全文或精确值字符串， Elasticsearch 需要知道每个域中数据的类型。<a id="id-1.4.8.17.2.1" class="indexterm"></a>这个信息包含在映射中。</p><p>如 <a class="xref" href="data-in-data-out.html" title="数据输入和输出"><em>数据输入和输出</em></a> 中解释的，<a id="id-1.4.8.17.3.2" class="indexterm"></a>
<a id="id-1.4.8.17.3.3" class="indexterm"></a>索引中每个文档都有 <span class="emphasis"><em>类型</em></span> 。每种类型都有它自己的 <span class="emphasis"><em>映射</em></span> ，或者 <span class="emphasis"><em>模式定义</em></span> 。<a id="id-1.4.8.17.3.7" class="indexterm"></a>映射定义了类型中的域，每个域的数据类型，以及Elasticsearch如何处理这些域。映射也用于配置与类型有关的元数据。</p><p>我们会在 <a class="xref" href="mapping.html" title="类型和映射">类型和映射</a> 详细讨论映射。本节，我们只讨论足够让你入门的内容。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="core-fields"></a>核心简单域类型<a xmlns="" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide/edit/cn/052_Mapping_Analysis/45_Mapping.asciidoc" class="edit_me" title="在 GitHub 上编辑本页" rel="nofollow">编辑</a></h3></div></div></div><p>Elasticsearch 支持<a id="id-1.4.8.17.5.2.1" class="indexterm"></a>
<a id="id-1.4.8.17.5.2.2" class="indexterm"></a><a id="id-1.4.8.17.5.2.3" class="indexterm"></a>
<a id="id-1.4.8.17.5.2.4" class="indexterm"></a>如下简单域类型：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
字符串: <code class="literal">string</code>
</li><li class="listitem">
整数 : <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">integer</code>, <code class="literal">long</code>
</li><li class="listitem">
浮点数: <code class="literal">float</code>, <code class="literal">double</code>
</li><li class="listitem">
布尔型: <code class="literal">boolean</code>
</li><li class="listitem">
日期: <code class="literal">date</code>
</li></ul></div><p>当你索引一个包含新域的文档--之前未曾出现-- Elasticsearch <a id="id-1.4.8.17.5.4.1" class="indexterm"></a>
<a id="id-1.4.8.17.5.4.2" class="indexterm"></a>
<a id="id-1.4.8.17.5.4.3" class="indexterm"></a><a id="id-1.4.8.17.5.4.4" class="indexterm"></a>
<a id="id-1.4.8.17.5.4.5" class="indexterm"></a>
<a id="id-1.4.8.17.5.4.6" class="indexterm"></a><a id="id-1.4.8.17.5.4.7" class="indexterm"></a><a id="id-1.4.8.17.5.4.8" class="indexterm"></a><a id="id-1.4.8.17.5.4.9" class="indexterm"></a><a id="id-1.4.8.17.5.4.10" class="indexterm"></a><a id="id-1.4.8.17.5.4.11" class="indexterm"></a><a id="id-1.4.8.17.5.4.12" class="indexterm"></a>
<a id="id-1.4.8.17.5.4.13" class="indexterm"></a>会使用 <a class="link" href="dynamic-mapping.html" title="动态映射"><span class="emphasis"><em>动态映射</em></span></a> ，通过JSON中基本数据类型，尝试猜测域类型，使用如下规则：</p><div class="informaltable"><table cellpadding="4px" border="0"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td valign="top">
<p>
<span class="strong strong"><strong>JSON type</strong></span>                       
</p>
</td><td valign="top">
<p>
<span class="strong strong"><strong>域 type</strong></span>
</p>
</td></tr><tr><td valign="top">
<p>
布尔型: <code class="literal">true</code> 或者 <code class="literal">false</code>         
</p>
</td><td valign="top">
<p>
<code class="literal">boolean</code>
</p>
</td></tr><tr><td valign="top">
<p>
整数: <code class="literal">123</code>                
</p>
</td><td valign="top">
<p>
<code class="literal">long</code>
</p>
</td></tr><tr><td valign="top">
<p>
浮点数: <code class="literal">123.45</code>           
</p>
</td><td valign="top">
<p>
<code class="literal">double</code>
</p>
</td></tr><tr><td valign="top">
<p>
字符串，有效日期: <code class="literal">2014-09-15</code> 
</p>
</td><td valign="top">
<p>
<code class="literal">date</code>
</p>
</td></tr><tr><td valign="top">
<p>
字符串: <code class="literal">foo bar</code>                
</p>
</td><td valign="top">
<p>
<code class="literal">string</code>
</p>
</td></tr></tbody></table></div><div xmlns="" class="note admon"><div class="icon"><img alt="注意" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">这意味着如果你通过引号( <code class="literal">"123"</code> )索引一个数字，它会被映射为 <code class="literal">string</code> 类型，而不是 <code class="literal">long</code> 。但是，如果这个域已经映射为 <code class="literal">long</code> ，那么 Elasticsearch 会尝试将这个字符串转化为 long ，如果无法转化，则抛出一个异常。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_查看映射"></a>查看映射<a xmlns="" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide/edit/cn/052_Mapping_Analysis/45_Mapping.asciidoc" class="edit_me" title="在 GitHub 上编辑本页" rel="nofollow">编辑</a></h3></div></div></div><p>通过 <code class="literal">/_mapping</code> ，我们可以查看 Elasticsearch 在一个或多个索引中的一个或多个类型的映射<a id="id-1.4.8.17.6.2.2" class="indexterm"></a>
<a id="id-1.4.8.17.6.2.3" class="indexterm"></a>。在 <a class="link" href="mapping-analysis.html" title="映射和分析">开始章节</a> ，我们已经取得索引 <code class="literal">gb</code> 中类型 <code class="literal">tweet</code> 的映射：</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /gb/_mapping/tweet</pre></div><p>Elasticsearch 根据我们索引的文档，为<a id="id-1.4.8.17.6.4.1" class="indexterm"></a>域(称为 <span class="emphasis"><em>属性</em></span> )动态生成的映射。</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">{
   "gb": {
      "mappings": {
         "tweet": {
            "properties": {
               "date": {
                  "type": "date",
                  "format": "strict_date_optional_time||epoch_millis"
               },
               "name": {
                  "type": "string"
               },
               "tweet": {
                  "type": "string"
               },
               "user_id": {
                  "type": "long"
               }
            }
         }
      }
   }
}</pre></div><div xmlns="" class="tip admon"><div class="icon"><img alt="提示" src="images/icons/tip.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">错误的映射，例如 <a id="id-1.4.8.17.6.6.1.1" class="indexterm"></a>
<a id="id-1.4.8.17.6.6.1.2" class="indexterm"></a>将 <code class="literal">age</code> 域映射为 <code class="literal">string</code> 类型，而不是 <code class="literal">integer</code> ，会导致查询出现令人困惑的结果。</p><p xmlns="http://www.w3.org/1999/xhtml">检查一下！而不是假设你的映射是正确的。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="custom-field-mappings"></a>自定义域映射<a xmlns="" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide/edit/cn/052_Mapping_Analysis/45_Mapping.asciidoc" class="edit_me" title="在 GitHub 上编辑本页" rel="nofollow">编辑</a></h3></div></div></div><p>尽管在很多情况下基本域数据类型<a id="id-1.4.8.17.7.2.1" class="indexterm"></a>
<a id="id-1.4.8.17.7.2.2" class="indexterm"></a><a id="id-1.4.8.17.7.2.3" class="indexterm"></a>
<a id="id-1.4.8.17.7.2.4" class="indexterm"></a>已经够用，但你经常需要为单独域自定义映射<a id="id-1.4.8.17.7.2.5" class="indexterm"></a>
<a id="id-1.4.8.17.7.2.6" class="indexterm"></a>，特别是字符串域。自定义映射允许你执行下面的操作：</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
全文字符串域和精确值字符串域的区别
</li><li class="listitem">
使用特定语言分析器
</li><li class="listitem">
优化域以适应部分匹配
</li><li class="listitem">
指定自定义数据格式
</li><li class="listitem">
还有更多
</li></ul></div><p>域最重要的属性是 <code class="literal">type</code> 。对于不是 <code class="literal">string</code> 的域，你一般只需要设置 <code class="literal">type</code> ：</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">{
    "number_of_clicks": {
        "type": "integer"
    }
}</pre></div><p>默认， <code class="literal">string</code> 类型域会被认为包含全文。就是说，它们的值在索引前，会通过<a id="id-1.4.8.17.7.6.2" class="indexterm"></a>
<a id="id-1.4.8.17.7.6.3" class="indexterm"></a>一个分析器，针对于这个域的查询在搜索前也会经过一个分析器。</p><p><code class="literal">string</code> 域映射的两个最重要<a id="id-1.4.8.17.7.7.2" class="indexterm"></a>
<a id="id-1.4.8.17.7.7.3" class="indexterm"></a>属性是 <code class="literal">index</code> 和 <code class="literal">analyzer</code> 。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_index_2"></a>index<a xmlns="" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide/edit/cn/052_Mapping_Analysis/45_Mapping.asciidoc" class="edit_me" title="在 GitHub 上编辑本页" rel="nofollow">编辑</a></h4></div></div></div><p><code class="literal">index</code> 属性控制<a id="id-1.4.8.17.7.8.2.2" class="indexterm"></a>怎样索引字符串。它可以是下面三个值：</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<code class="literal">analyzed</code>
</span></dt><dd>
   首先分析字符串，然后索引它。换句话说，以全文索引这个域。
</dd><dt><span class="term">
<code class="literal">not_analyzed</code>
</span></dt><dd>
   索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。
</dd><dt><span class="term">
<code class="literal">no</code>
</span></dt><dd>
   不索引这个域。这个域不会被搜索到。
</dd></dl></div><p><code class="literal">string</code> 域 <code class="literal">index</code> 属性默认是 <code class="literal">analyzed</code> 。如果我们想映射这个字段为一个精确值，我们需要设置它为 <code class="literal">not_analyzed</code> ：</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">{
    "tag": {
        "type":     "string",
        "index":    "not_analyzed"
    }
}</pre></div><div xmlns="" class="note admon"><div class="icon"><img alt="注意" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">其他简单类型（例如 <code class="literal">long</code> ， <code class="literal">double</code> ， <code class="literal">date</code> 等）也接受 <code class="literal">index</code> 参数，但有意义的值只有 <code class="literal">no</code> 和 <code class="literal">not_analyzed</code> ，
因为它们永远不会被分析。</p></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_analyzer"></a>analyzer<a xmlns="" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide/edit/cn/052_Mapping_Analysis/45_Mapping.asciidoc" class="edit_me" title="在 GitHub 上编辑本页" rel="nofollow">编辑</a></h4></div></div></div><p>对于 <code class="literal">analyzed</code> 字符串域，用<a id="id-1.4.8.17.7.9.2.2" class="indexterm"></a> <code class="literal">analyzer</code> 属性指定在搜索和索引时使用的分析器。默认， Elasticsearch 使用 <code class="literal">standard</code> 分析器，<a id="id-1.4.8.17.7.9.2.5" class="indexterm"></a>
<a id="id-1.4.8.17.7.9.2.6" class="indexterm"></a> 但你可以指定一个内置的分析器替代它，例如<a id="id-1.4.8.17.7.9.2.7" class="indexterm"></a>
<code class="literal">whitespace</code> 、 <code class="literal">simple</code> 和 `english`：</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">{
    "tweet": {
        "type":     "string",
        "analyzer": "english"
    }
}</pre></div><p>在 <a class="xref" href="custom-analyzers.html" title="自定义分析器">自定义分析器</a> ，我们会展示怎样定义和使用自定义分析器。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="updating-a-mapping"></a>更新映射<a xmlns="" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide/edit/cn/052_Mapping_Analysis/45_Mapping.asciidoc" class="edit_me" title="在 GitHub 上编辑本页" rel="nofollow">编辑</a></h3></div></div></div><p>当你首次<a id="id-1.4.8.17.8.2.1" class="indexterm"></a>
<a id="id-1.4.8.17.8.2.2" class="indexterm"></a>
<a id="id-1.4.8.17.8.2.3" class="indexterm"></a><a id="id-1.4.8.17.8.2.4" class="indexterm"></a>
<a id="id-1.4.8.17.8.2.5" class="indexterm"></a>创建一个索引的时候，可以指定类型的映射。你也可以使用 <code class="literal">/_mapping</code> 为新类型（或者为存在的类型更新映射）增加映射。</p><div xmlns="" class="note admon"><div class="icon"><img alt="注意" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">尽管你可以 <span class="emphasis"><em>增加_ 一个存在的映射，你不能 _修改</em></span> 存在的域映射。如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。</p></div></div><p>我们可以更新一个映射来添加一个新域，但不能将一个存在的域从 <code class="literal">analyzed</code> 改为 <code class="literal">not_analyzed</code> 。</p><p>为了描述指定映射的两种方式，我们先删除 <code class="literal">gd</code> 索引：</p><div xmlns="" class="pre_wrapper lang-sh"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-sh">DELETE /gb</pre></div><div xmlns="" class="sense_widget" data-snippet="snippets/052_Mapping_Analysis/45_Mapping.json"></div><p>然后创建一个新索引，指定 <code class="literal">tweet</code> 域使用 <code class="literal">english</code> 分析器：</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">PUT /gb <a id="CO19-1"></a><i xmlns="" class="conum" data-value="1"></i>
{
  "mappings": {
    "tweet" : {
      "properties" : {
        "tweet" : {
          "type" :    "string",
          "analyzer": "english"
        },
        "date" : {
          "type" :   "date"
        },
        "name" : {
          "type" :   "string"
        },
        "user_id" : {
          "type" :   "long"
        }
      }
    }
  }
}</pre></div><div xmlns="" class="sense_widget" data-snippet="snippets/052_Mapping_Analysis/45_Mapping.json"></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO19-1"><i xmlns="" class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
通过消息体中指定的 <code class="literal">mappings</code> 创建了索引。
</p></td></tr></table></div><p>稍后，我们决定在 <code class="literal">tweet</code> 映射增加一个新的名为 <code class="literal">tag</code> 的 <code class="literal">not_analyzed</code> 的文本域，使用 <code class="literal">_mapping</code> ：</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">PUT /gb/_mapping/tweet
{
  "properties" : {
    "tag" : {
      "type" :    "string",
      "index":    "not_analyzed"
    }
  }
}</pre></div><div xmlns="" class="sense_widget" data-snippet="snippets/052_Mapping_Analysis/45_Mapping.json"></div><p>注意，我们不需要再次列出所有已存在的域，因为无论如何我们都无法改变它们。新域已经被合并到存在的映射中。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_测试映射"></a>测试映射<a xmlns="" href="https://github.com/elasticsearch-cn/elasticsearch-definitive-guide/edit/cn/052_Mapping_Analysis/45_Mapping.asciidoc" class="edit_me" title="在 GitHub 上编辑本页" rel="nofollow">编辑</a></h3></div></div></div><p>你可以使用 <code class="literal">analyze</code> API <a id="id-1.4.8.17.9.2.2" class="indexterm"></a>
<a id="id-1.4.8.17.9.2.3" class="indexterm"></a> 测试字符串域的映射。比较下面两个请求的输出：</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /gb/_analyze
{
  "field": "tweet",
  "text": "Black-cats" <a id="CO20-1"></a><i xmlns="" class="conum" data-value="1"></i>
}

GET /gb/_analyze
{
  "field": "tag",
  "text": "Black-cats" <a id="CO20-2"></a><i xmlns="" class="conum" data-value="2"></i>
}</pre></div><div xmlns="" class="sense_widget" data-snippet="snippets/052_Mapping_Analysis/45_Mapping.json"></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO20-1"><i xmlns="" class="conum" data-value="1"></i></a> <a href="#CO20-2"><i xmlns="" class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>
消息体里面传输我们想要分析的文本。
</p></td></tr></table></div><p><code class="literal">tweet</code> 域产生两个词条 <code class="literal">black</code> 和 <code class="literal">cat</code> ， <code class="literal">tag</code> 域产生单独的词条 <code class="literal">Black-cats</code> 。换句话说，我们的映射正常工作。</p></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="analysis-intro.html">
              « 
              分析与分析器</a>
           
        </span><span class="next">
           
          <a href="complex-core-fields.html">复杂核心域类型
               »
            </a></span></div></body></html>