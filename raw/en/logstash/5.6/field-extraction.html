<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Extracting Fields and Wrangling Data
        | Logstash Reference [5.6]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Logstash Reference [5.6]" /><link rel="up" href="transformation.html" title="Transforming Data" /><link rel="prev" href="data-deserialization.html" title="Deserializing Data" /><link rel="next" href="lookup-enrichment.html" title="Enriching Data with Lookups" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Logstash/Reference/5.6" /><meta xmlns="" name="DC.subject" content="Logstash" /><meta xmlns="" name="DC.identifier" content="5.6" /></head><body><div xmlns="" class="page_header">You are looking at documentation for an older release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Logstash Reference
      [5.6]
    </a></span> » <span class="breadcrumb-link"><a href="transformation.html">Transforming Data</a></span> » <span class="breadcrumb-node">Extracting Fields and Wrangling Data</span></div><div xmlns="" class="navheader"><span class="prev"><a href="data-deserialization.html">
              « 
              Deserializing Data</a>
           
        </span><span class="next">
           
          <a href="lookup-enrichment.html">Enriching Data with Lookups
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="field-extraction"></a>Extracting Fields and Wrangling Data<a xmlns="" href="https://github.com/elastic/logstash/edit/5.6/docs/static/transforming-data.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>The plugins described in this section are useful for extracting fields and
parsing unstructured data into fields.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><a class="link" href="plugins-filters-dissect.html" title="Dissect filter plugin">dissect filter</a></span></dt><dd><p class="simpara">Extracts unstructured event data into fields by using delimiters. The dissect
filter does not use regular expressions and is very fast. However, if the
structure of the data varies from line to line, the grok filter is more
suitable.</p><p class="simpara">For example, let’s say you have a log that contains the following message:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">Apr 26 12:20:02 localhost systemd[1]: Starting system activity accounting tool...</pre></div><p class="simpara">The following config dissects the message:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">filter {
  dissect {
    mapping =&gt; { "message" =&gt; "%{ts} %{+ts} %{+ts} %{src} %{prog}[%{pid}]: %{msg}" }
  }
}</pre></div><p class="simpara">After the dissect filter is applied, the event will be dissected into the following
fields:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">{
  "msg"        =&gt; "Starting system activity accounting tool...",
  "@timestamp" =&gt; 2017-04-26T19:33:39.257Z,
  "src"        =&gt; "localhost",
  "@version"   =&gt; "1",
  "host"       =&gt; "localhost.localdomain",
  "pid"        =&gt; "1",
  "message"    =&gt; "Apr 26 12:20:02 localhost systemd[1]: Starting system activity accounting tool...",
  "type"       =&gt; "stdin",
  "prog"       =&gt; "systemd",
  "ts"         =&gt; "Apr 26 12:20:02"
}</pre></div></dd><dt><span class="term"><a class="link" href="plugins-filters-kv.html" title="Kv filter plugin">kv filter</a></span></dt><dd><p class="simpara">Parses key-value pairs.</p><p class="simpara">For example, let’s say you have a log message that contains the following
key-value pairs:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">ip=1.2.3.4 error=REFUSED</pre></div><p class="simpara">The following config parses the key-value pairs into fields:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">filter {
  kv { }
}</pre></div><p class="simpara">After the filter is applied, the event in the example will have these fields:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="literal">ip: 1.2.3.4</code></li><li class="listitem"><code class="literal">error: REFUSED</code></li></ul></div></dd><dt><span class="term"><a class="link" href="plugins-filters-grok.html" title="Grok filter plugin">grok filter</a></span></dt><dd><p class="simpara">Parses unstructured event data into fields. This tool is perfect for syslog
logs, Apache and other webserver logs, MySQL logs, and in general, any log
format that is generally written for humans and not computer consumption.
Grok works by combining text patterns into something that matches your
logs.</p><p class="simpara">For example, let’s say you have an HTTP request log that contains
the following message:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">55.3.244.1 GET /index.html 15824 0.043</pre></div><p class="simpara">The following config parses the message into fields:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">filter {
  grok {
    match =&gt; { "message" =&gt; "%{IP:client} %{WORD:method} %{URIPATHPARAM:request} %{NUMBER:bytes} %{NUMBER:duration}" }
  }
}</pre></div><p class="simpara">After the filter is applied, the event in the example will have these fields:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="literal">client: 55.3.244.1</code></li><li class="listitem"><code class="literal">method: GET</code></li><li class="listitem"><code class="literal">request: /index.html</code></li><li class="listitem"><code class="literal">bytes: 15824</code></li><li class="listitem"><code class="literal">duration: 0.043</code></li></ul></div></dd></dl></div><div xmlns="" class="tip admon"><div class="icon"><img alt="Tip" src="images/icons/tip.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">If you need help building grok patterns, try out the
<a class="ulink" href="https://www.elastic.co/guide/en/kibana/5.6/xpack-grokdebugger.html" target="_top">Grok Debugger</a>. The Grok Debugger is an
X-Pack feature under the Basic License and is therefore <span class="strong strong"><strong>free to use</strong></span>.</p></div></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="data-deserialization.html">
              « 
              Deserializing Data</a>
           
        </span><span class="next">
           
          <a href="lookup-enrichment.html">Enriching Data with Lookups
               »
            </a></span></div></body></html>