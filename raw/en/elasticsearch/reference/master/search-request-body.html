<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Request Body Search | Elasticsearch Reference [master] | Elastic</title>
<link rel="home" href="index.html" title="Elasticsearch Reference [master]"/>
<link rel="up" href="search.html" title="Search APIs"/>
<link rel="prev" href="search-search.html" title="Search API"/>
<link rel="next" href="async-search.html" title="Async search"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/master"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="master"/>
</head>
<body><div class="page_header">
You are looking at preliminary documentation for a future release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference [master]</a></span>
»
<span class="breadcrumb-link"><a href="rest-apis.html">REST APIs</a></span>
»
<span class="breadcrumb-link"><a href="search.html">Search APIs</a></span>
»
<span class="breadcrumb-node">Request Body Search</span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-search.html">« Search API</a>
</span>
<span class="next">
<a href="async-search.html">Async search »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-request-body"></a>Request Body Search<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h2>
</div></div></div>
<p>Specifies search criteria as request body parameters.</p>
<a id="9b3f89816691847269e688bea82b8f06"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my-index-000001/_search
{
  "query" : {
    "term" : { "user.id" : "kimchy" }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2048.console"></div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-request-body-api-request"></a>Request<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">GET /&lt;target&gt;/_search
{
  "query": {&lt;parameters&gt;}
}</code></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-request-body-api-desc"></a>Description<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>The search request can be executed with a search DSL, which includes the
<a class="xref" href="query-dsl.html" title="Query DSL">Query DSL</a>, within its body.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-request-body-api-path-params"></a>Path parameters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">&lt;target&gt;</code>
</span>
</dt>
<dd>
<p>
(Optional, string)
Comma-separated list of data streams, indices, and index aliases to search.
Wildcard (<code class="literal">*</code>) expressions are supported.
</p>
<p>To search all data streams and indices in a cluster, omit this parameter or use
<code class="literal">_all</code> or <code class="literal">*</code>.</p>
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-request-body-api-request-body"></a>Request body<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See the search API&#8217;s <a class="xref" href="search-search.html#search-search-api-request-body" title="Request body">request body parameters</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_fast_check_for_any_matching_docs"></a>Fast check for any matching docs<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">terminate_after</code> is always applied <span class="strong strong"><strong>after</strong></span> the <code class="literal">post_filter</code> and stops
       the query as well as the aggregation executions when enough hits have been
       collected on the shard. Though the doc count on aggregations may not reflect
       the <code class="literal">hits.total</code> in the response since aggregations are applied <span class="strong strong"><strong>before</strong></span> the
       post filtering.</p>
</div>
</div>
<p>In case we only want to know if there are any documents matching a
specific query, we can set the <code class="literal">size</code> to <code class="literal">0</code> to indicate that we are not
interested in the search results. Also we can set <code class="literal">terminate_after</code> to <code class="literal">1</code>
to indicate that the query execution can be terminated whenever the first
matching document was found (per shard).</p>
<a id="14254a0e725044faedf9370ead76f6ce"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search?q=user.id:elkbee&amp;size=0&amp;terminate_after=1</pre>
</div>
<div class="console_widget" data-snippet="snippets/2049.console"></div>
<p>The response will not contain any hits as the <code class="literal">size</code> was set to <code class="literal">0</code>. The
<code class="literal">hits.total</code> will be either equal to <code class="literal">0</code>, indicating that there were no
matching documents, or greater than <code class="literal">0</code> meaning that there were at least
as many documents matching the query when it was early terminated.
Also if the query was terminated early, the <code class="literal">terminated_early</code> flag will
be set to <code class="literal">true</code> in the response.</p>
<a id="31fa804420aad7728f9ba9f20dc1a9c5"></a>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "took": 3,
  "timed_out": false,
  "terminated_early": true,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": null,
    "hits": []
  }
}</pre>
</div>
<p>The <code class="literal">took</code> time in the response contains the milliseconds that this request
took for processing, beginning quickly after the node received the query, up
until all search related work is done and before the above JSON is returned
to the client. This means it includes the time spent waiting in thread pools,
executing a distributed search across the whole cluster and gathering all the
results.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-docvalue-fields"></a>Doc value fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="search-fields.html#docvalue-fields" title="Doc value fields">Doc value fields</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-collapse"></a>Field collapsing<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="collapse-search-results.html" title="Collapse search results"><em>Collapse search results</em></a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-highlighting"></a>Highlighting<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="highlighting.html" title="Highlighting"><em>Highlighting</em></a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-index-boost"></a>Index Boost<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/index-boost.asciidoc">edit</a></h3>
</div></div></div>
<p>Allows to configure different boost level per index when searching
across more than one indices. This is very handy when hits coming from
one index matter more than hits coming from another index (think social
graph where each user has an index).</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<h3>Deprecated in 5.2.0.</h3>
<p>This format is deprecated. Please use array format instead.</p>
</div>
</div>
<a id="58d5949ca957a128e8fb45750e4a7ca7"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "indices_boost" : [
    { "index1" : 1.4 },
    { "index2" : 1.3 }
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2050.console"></div>
<p>Index aliases and wildcard expressions can also be used:</p>
<a id="c68ed83a7135bcf195b6a7ff139f3a21"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "indices_boost" : [
    { "alias1" : 1.4 },
    { "index*" : 1.3 }
  ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2051.console"></div>
<p>If multiple matches are found, the first match will be used. For example, if an
index is included in both <code class="literal">alias1</code> and <code class="literal">index*</code>, boost value of <code class="literal">1.4</code> is applied.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-inner-hits"></a>Inner hits<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/inner-hits.asciidoc">edit</a></h3>
</div></div></div>
<p>The <a class="xref" href="parent-join.html" title="Join data type">parent-join</a> and <a class="xref" href="nested.html" title="Nested data type">nested</a> features allow the return of documents that
have matches in a different scope. In the parent/child case, parent documents are returned based on matches in child
documents or child documents are returned based on matches in parent documents. In the nested case, documents are returned
based on matches in nested inner objects.</p>
<p>In both cases, the actual matches in the different scopes that caused a document to be returned are hidden. In many cases,
it&#8217;s very useful to know which inner nested objects (in the case of nested) or children/parent documents (in the case
of parent/child) caused certain information to be returned. The inner hits feature can be used for this. This feature
returns per search hit in the search response additional nested hits that caused a search hit to match in a different scope.</p>
<p>Inner hits can be used by defining an <code class="literal">inner_hits</code> definition on a <code class="literal">nested</code>, <code class="literal">has_child</code> or <code class="literal">has_parent</code> query and filter.
The structure looks like this:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"&lt;query&gt;" : {
    "inner_hits" : {
        &lt;inner_hits_options&gt;
    }
}</pre>
</div>
<p>If <code class="literal">inner_hits</code> is defined on a query that supports it then each search hit will contain an <code class="literal">inner_hits</code> json object with the following structure:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"hits": [
     {
        "_index": ...,
        "_type": ...,
        "_id": ...,
        "inner_hits": {
           "&lt;inner_hits_name&gt;": {
              "hits": {
                 "total": ...,
                 "hits": [
                    {
                       "_id": ...,
                       ...
                    },
                    ...
                 ]
              }
           }
        },
        ...
     },
     ...
]</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_options_6"></a>Options<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/inner-hits.asciidoc">edit</a></h4>
</div></div></div>
<p>Inner hits support the following options:</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">from</code>
</p>
</td>
<td valign="top">
<p>
The offset from where the first hit to fetch for each <code class="literal">inner_hits</code> in the returned regular search hits.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">size</code>
</p>
</td>
<td valign="top">
<p>
The maximum number of hits to return per <code class="literal">inner_hits</code>. By default the top three matching hits are returned.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">sort</code>
</p>
</td>
<td valign="top">
<p>
How the inner hits should be sorted per <code class="literal">inner_hits</code>. By default the hits are sorted by the score.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">name</code>
</p>
</td>
<td valign="top">
<p>
The name to be used for the particular inner hit definition in the response. Useful when multiple inner hits
have been defined in a single search request. The default depends in which query the inner hit is defined.
For <code class="literal">has_child</code> query and filter this is the child type, <code class="literal">has_parent</code> query and filter this is the parent type
and the nested query and filter this is the nested path.
</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>Inner hits also supports the following per document features:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="highlighting.html" title="Highlighting">Highlighting</a>
</li>
<li class="listitem">
<a class="xref" href="search-search.html#request-body-search-explain">Explain</a>
</li>
<li class="listitem">
<a class="xref" href="search-request-body.html#request-body-search-source-filtering" title="Source filtering">Source filtering</a>
</li>
<li class="listitem">
<a class="xref" href="search-fields.html#script-fields" title="Script fields">Script fields</a>
</li>
<li class="listitem">
<a class="xref" href="search-fields.html#docvalue-fields" title="Doc value fields">Doc value fields</a>
</li>
<li class="listitem">
<a class="xref" href="search-search.html#request-body-search-version">Include versions</a>
</li>
<li class="listitem">
<a class="xref" href="search-search.html#request-body-search-seq-no-primary-term">Include Sequence Numbers and Primary Terms</a>
</li>
</ul>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="nested-inner-hits"></a>Nested inner hits<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/inner-hits.asciidoc">edit</a></h4>
</div></div></div>
<p>The nested <code class="literal">inner_hits</code> can be used to include nested inner objects as inner hits to a search hit.</p>
<a id="2a91e1fb8ad93a188fa9d77ec01bc431"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT test
{
  "mappings": {
    "properties": {
      "comments": {
        "type": "nested"
      }
    }
  }
}

PUT test/_doc/1?refresh
{
  "title": "Test title",
  "comments": [
    {
      "author": "kimchy",
      "number": 1
    },
    {
      "author": "nik9000",
      "number": 2
    }
  ]
}

POST test/_search
{
  "query": {
    "nested": {
      "path": "comments",
      "query": {
        "match": {"comments.number" : 2}
      },
      "inner_hits": {} <a id="CO618-1"></a><i class="conum" data-value="1"></i>
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2052.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO618-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The inner hit definition in the nested query. No other options need to be defined.</p>
</td>
</tr>
</table>
</div>
<p>An example of a response snippet that could be generated from the above search request:</p>
<a id="cb58a734d14c0a1e2743f7449d42e9c9"></a>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...,
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 1.0,
    "hits": [
      {
        "_index": "test",
        "_id": "1",
        "_score": 1.0,
        "_source": ...,
        "inner_hits": {
          "comments": { <a id="CO619-1"></a><i class="conum" data-value="1"></i>
            "hits": {
              "total" : {
                  "value": 1,
                  "relation": "eq"
              },
              "max_score": 1.0,
              "hits": [
                {
                  "_index": "test",
                  "_id": "1",
                  "_nested": {
                    "field": "comments",
                    "offset": 1
                  },
                  "_score": 1.0,
                  "_source": {
                    "author": "nik9000",
                    "number": 2
                  }
                }
              ]
            }
          }
        }
      }
    ]
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO619-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The name used in the inner hit definition in the search request. A custom key can be used via the <code class="literal">name</code> option.</p>
</td>
</tr>
</table>
</div>
<p>The <code class="literal">_nested</code> metadata is crucial in the above example, because it defines from what inner nested object this inner hit
came from. The <code class="literal">field</code> defines the object array field the nested hit is from and the <code class="literal">offset</code> relative to its location
in the <code class="literal">_source</code>. Due to sorting and scoring the actual location of the hit objects in the <code class="literal">inner_hits</code> is usually
different than the location a nested inner object was defined.</p>
<p>By default the <code class="literal">_source</code> is returned also for the hit objects in <code class="literal">inner_hits</code>, but this can be changed. Either via
<code class="literal">_source</code> filtering feature part of the source can be returned or be disabled. If stored fields are defined on the
nested level these can also be returned via the <code class="literal">fields</code> feature.</p>
<p>An important default is that the <code class="literal">_source</code> returned in hits inside <code class="literal">inner_hits</code> is relative to the <code class="literal">_nested</code> metadata.
So in the above example only the comment part is returned per nested hit and not the entire source of the top level
document that contained the comment.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="nested-inner-hits-source"></a>Nested inner hits and <code class="literal">_source</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/inner-hits.asciidoc">edit</a></h4>
</div></div></div>
<p>Nested document don&#8217;t have a <code class="literal">_source</code> field, because the entire source of document is stored with the root document under
its <code class="literal">_source</code> field. To include the source of just the nested document, the source of the root document is parsed and just
the relevant bit for the nested document is included as source in the inner hit. Doing this for each matching nested document
has an impact on the time it takes to execute the entire search request, especially when <code class="literal">size</code> and the inner hits' <code class="literal">size</code>
are set higher than the default. To avoid the relatively expensive source extraction for nested inner hits, one can disable
including the source and solely rely on doc values fields. Like this:</p>
<a id="983fbb78e57e8fe98db38cf2d217e943"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT test
{
  "mappings": {
    "properties": {
      "comments": {
        "type": "nested"
      }
    }
  }
}

PUT test/_doc/1?refresh
{
  "title": "Test title",
  "comments": [
    {
      "author": "kimchy",
      "text": "comment text"
    },
    {
      "author": "nik9000",
      "text": "words words words"
    }
  ]
}

POST test/_search
{
  "query": {
    "nested": {
      "path": "comments",
      "query": {
        "match": {"comments.text" : "words"}
      },
      "inner_hits": {
        "_source" : false,
        "docvalue_fields" : [
          "comments.text.keyword"
        ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2053.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="hierarchical-nested-inner-hits"></a>Hierarchical levels of nested object fields and inner hits.<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/inner-hits.asciidoc">edit</a></h4>
</div></div></div>
<p>If a mapping has multiple levels of hierarchical nested object fields each level can be accessed via dot notated path.
For example if there is a <code class="literal">comments</code> nested field that contains a <code class="literal">votes</code> nested field and votes should directly be returned
with the root hits then the following path can be defined:</p>
<a id="79feb4a0c0a21b7015a52f9736cd4683"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT test
{
  "mappings": {
    "properties": {
      "comments": {
        "type": "nested",
        "properties": {
          "votes": {
            "type": "nested"
          }
        }
      }
    }
  }
}

PUT test/_doc/1?refresh
{
  "title": "Test title",
  "comments": [
    {
      "author": "kimchy",
      "text": "comment text",
      "votes": []
    },
    {
      "author": "nik9000",
      "text": "words words words",
      "votes": [
        {"value": 1 , "voter": "kimchy"},
        {"value": -1, "voter": "other"}
      ]
    }
  ]
}

POST test/_search
{
  "query": {
    "nested": {
      "path": "comments.votes",
        "query": {
          "match": {
            "comments.votes.voter": "kimchy"
          }
        },
        "inner_hits" : {}
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2054.console"></div>
<p>Which would look like:</p>
<a id="bb924187bb9a4f4f07e55042f1f4b639"></a>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...,
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.6931471,
    "hits": [
      {
        "_index": "test",
        "_id": "1",
        "_score": 0.6931471,
        "_source": ...,
        "inner_hits": {
          "comments.votes": { <a id="CO620-1"></a><i class="conum" data-value="1"></i>
            "hits": {
              "total" : {
                  "value": 1,
                  "relation": "eq"
              },
              "max_score": 0.6931471,
              "hits": [
                {
                  "_index": "test",
                  "_id": "1",
                  "_nested": {
                    "field": "comments",
                    "offset": 1,
                    "_nested": {
                      "field": "votes",
                      "offset": 0
                    }
                  },
                  "_score": 0.6931471,
                  "_source": {
                    "value": 1,
                    "voter": "kimchy"
                  }
                }
              ]
            }
          }
        }
      }
    ]
  }
}</pre>
</div>
<p>This indirect referencing is only supported for nested inner hits.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="parent-child-inner-hits"></a>Parent/child inner hits<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/inner-hits.asciidoc">edit</a></h4>
</div></div></div>
<p>The parent/child <code class="literal">inner_hits</code> can be used to include parent or child:</p>
<a id="3f5b5bee692e7d4b0992dc0a64e95a60"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT test
{
  "mappings": {
    "properties": {
      "my_join_field": {
        "type": "join",
        "relations": {
          "my_parent": "my_child"
        }
      }
    }
  }
}

PUT test/_doc/1?refresh
{
  "number": 1,
  "my_join_field": "my_parent"
}

PUT test/_doc/2?routing=1&amp;refresh
{
  "number": 1,
  "my_join_field": {
    "name": "my_child",
    "parent": "1"
  }
}

POST test/_search
{
  "query": {
    "has_child": {
      "type": "my_child",
      "query": {
        "match": {
          "number": 1
        }
      },
      "inner_hits": {}    <a id="CO620-2"></a><i class="conum" data-value="1"></i>
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2055.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO620-1"><i class="conum" data-value="1"></i></a><a href="#CO620-2"></a></p>
</td>
<td align="left" valign="top">
<p>The inner hit definition like in the nested example.</p>
</td>
</tr>
</table>
</div>
<p>An example of a response snippet that could be generated from the above search request:</p>
<a id="20250d7a4c6c199116eff4f8bf45cf28"></a>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  ...,
  "hits": {
    "total": {
      "value": 1,
      "relation": "eq"
    },
    "max_score": 1.0,
    "hits": [
      {
        "_index": "test",
        "_id": "1",
        "_score": 1.0,
        "_source": {
          "number": 1,
          "my_join_field": "my_parent"
        },
        "inner_hits": {
          "my_child": {
            "hits": {
              "total": {
                "value": 1,
                "relation": "eq"
              },
              "max_score": 1.0,
              "hits": [
                {
                  "_index": "test",
                  "_id": "2",
                  "_score": 1.0,
                  "_routing": "1",
                  "_source": {
                    "number": 1,
                    "my_join_field": {
                      "name": "my_child",
                      "parent": "1"
                    }
                  }
                }
              ]
            }
          }
        }
      }
    ]
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-min-score"></a>min_score<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/min-score.asciidoc">edit</a></h3>
</div></div></div>
<p>Exclude documents which have a <code class="literal">_score</code> less than the minimum specified
in <code class="literal">min_score</code>:</p>
<a id="e93810be25fccf816d6fdf9b2efbe492"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "min_score": 0.5,
  "query" : {
    "term" : { "user" : "kimchy" }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2056.console"></div>
<p>Note, most times, this does not make much sense, but is provided for
advanced use cases.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-queries-and-filters"></a>Named queries<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="query-dsl-bool-query.html#named-queries" title="Named queries">Named queries</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-post-filter"></a>Post filter<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/post-filter.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">post_filter</code> is applied to the search <code class="literal">hits</code> at the very end of a search
request,  after aggregations have already been calculated. Its purpose is
best explained by example:</p>
<p>Imagine that you are selling shirts that have the following properties:</p>
<a id="1a81fe0186369838531e116e85aa4ccd"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /shirts
{
  "mappings": {
    "properties": {
      "brand": { "type": "keyword"},
      "color": { "type": "keyword"},
      "model": { "type": "keyword"}
    }
  }
}

PUT /shirts/_doc/1?refresh
{
  "brand": "gucci",
  "color": "red",
  "model": "slim"
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2057.console"></div>
<p>Imagine a user has specified two filters:</p>
<p><code class="literal">color:red</code> and <code class="literal">brand:gucci</code>.  You only want to show them red shirts made by
Gucci in the search results.  Normally you would do this with a
<a class="xref" href="query-dsl-bool-query.html" title="Boolean query"><code class="literal">bool</code> query</a>:</p>
<a id="f83eb6605c7c56e297a494b318400ef0"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /shirts/_search
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "color": "red"   }},
        { "term": { "brand": "gucci" }}
      ]
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2058.console"></div>
<p>However, you would also like to use <em>faceted navigation</em> to display a list of
other options that the user could click on.  Perhaps you have a <code class="literal">model</code> field
that would allow the user to limit their search results to red Gucci
<code class="literal">t-shirts</code> or <code class="literal">dress-shirts</code>.</p>
<p>This can be done with a
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html" title="Terms Aggregation"><code class="literal">terms</code> aggregation</a>:</p>
<a id="81f1b1e1d5c81683b6bf471c469e6046"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /shirts/_search
{
  "query": {
    "bool": {
      "filter": [
        { "term": { "color": "red"   }},
        { "term": { "brand": "gucci" }}
      ]
    }
  },
  "aggs": {
    "models": {
      "terms": { "field": "model" } <a id="CO621-1"></a><i class="conum" data-value="1"></i>
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2059.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO621-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Returns the most popular models of red shirts by Gucci.</p>
</td>
</tr>
</table>
</div>
<p>But perhaps you would also like to tell the user how many Gucci shirts are
available in <span class="strong strong"><strong>other colors</strong></span>. If you just add a <code class="literal">terms</code> aggregation on the
<code class="literal">color</code> field, you will only get back the color <code class="literal">red</code>, because your query
returns only red shirts by Gucci.</p>
<p>Instead, you want to include shirts of all colors during aggregation, then
apply the <code class="literal">colors</code> filter only to the search results.  This is the purpose of
the <code class="literal">post_filter</code>:</p>
<a id="48313f620c2871b6f4019b66be730109"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /shirts/_search
{
  "query": {
    "bool": {
      "filter": {
        "term": { "brand": "gucci" } <a id="CO622-1"></a><i class="conum" data-value="1"></i>
      }
    }
  },
  "aggs": {
    "colors": {
      "terms": { "field": "color" } <a id="CO622-2"></a><i class="conum" data-value="2"></i>
    },
    "color_red": {
      "filter": {
        "term": { "color": "red" } <a id="CO622-3"></a><i class="conum" data-value="3"></i>
      },
      "aggs": {
        "models": {
          "terms": { "field": "model" } <a id="CO622-4"></a><i class="conum" data-value="3"></i>
        }
      }
    }
  },
  "post_filter": { <a id="CO622-5"></a><i class="conum" data-value="4"></i>
    "term": { "color": "red" }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2060.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO622-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The main query now finds all shirts by Gucci, regardless of color.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO622-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">colors</code> agg returns popular colors for shirts by Gucci.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO622-3"><i class="conum" data-value="3"></i></a><a href="#CO622-4"></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">color_red</code> agg limits the <code class="literal">models</code> sub-aggregation
to <span class="strong strong"><strong>red</strong></span> Gucci shirts.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO622-5"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Finally, the <code class="literal">post_filter</code> removes colors other than red
from the search <code class="literal">hits</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-preference"></a>Preference<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/preference.asciidoc">edit</a></h3>
</div></div></div>
<p>Controls a <code class="literal">preference</code> of the shard copies on which to execute the search.  By
default, Elasticsearch selects from the available shard copies in an
unspecified order, taking the <a class="xref" href="modules-cluster.html#shard-allocation-awareness" title="Shard allocation awareness">allocation awareness</a> and
<a class="xref" href="search.html#search-adaptive-replica" title="Adaptive Replica Selection">adaptive replica selection</a> configuration into
account. However, it may sometimes be desirable to try and route certain
searches to certain sets of shard copies.</p>
<p>A possible use case would be to make use of per-copy caches like the
<a class="xref" href="shard-request-cache.html" title="Shard request cache settings">request cache</a>. Doing this, however, runs contrary to the
idea of search parallelization and can create hotspots on certain nodes because
the load might not be evenly distributed anymore.</p>
<p>The <code class="literal">preference</code> is a query string parameter which can be set to:</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">_only_local</code>
</p>
</td>
<td valign="top">
<p>
The operation will be executed only on shards allocated to the local
node.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_local</code>
</p>
</td>
<td valign="top">
<p>
The operation will be executed on shards allocated to the local node if
possible, and will fall back to other shards if not.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_prefer_nodes:abc,xyz</code>
</p>
</td>
<td valign="top">
<p>
The operation will be executed on nodes with one of the provided node
ids (<code class="literal">abc</code> or <code class="literal">xyz</code> in this case) if possible. If suitable shard copies
exist on more than one of the selected nodes then the order of
preference between these copies is unspecified.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_shards:2,3</code>
</p>
</td>
<td valign="top">
<p>
Restricts the operation to the specified shards. (<code class="literal">2</code> and <code class="literal">3</code> in this
case).  This preference can be combined with other preferences but it
has to appear first: <code class="literal">_shards:2,3|_local</code>
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_only_nodes:abc*,x*yz,...</code>
</p>
</td>
<td valign="top">
<p>
Restricts the operation to nodes specified according to the
<a class="xref" href="cluster.html" title="Cluster APIs">node specification</a>. If suitable shard copies exist on more
than one of the selected nodes then the order of preference between
these copies is unspecified.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
Custom (string) value
</p>
</td>
<td valign="top">
<p>
Any value that does not start with <code class="literal">_</code>. If two searches both give the same
custom string value for their preference and the underlying cluster state
does not change then the same ordering of shards will be used for the
searches. This does not guarantee that the exact same shards will be used
each time: the cluster state, and therefore the selected shards, may change
for a number of reasons including shard relocations and shard failures, and
nodes may sometimes reject searches causing fallbacks to alternative nodes.
However, in practice the ordering of shards tends to remain stable for long
periods of time. A good candidate for a custom preference value is something
like the web session id or the user name.
</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>For instance, use the user&#8217;s session ID <code class="literal">xyzabc123</code> as follows:</p>
<a id="547c2dc05154c639c49d43fcafe2a25e"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search?preference=xyzabc123
{
  "query": {
    "match": {
      "title": "elasticsearch"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2061.console"></div>
<p>This can be an effective strategy to increase usage of e.g. the request cache for
unique users running similar searches repeatedly by always hitting the same cache, while
requests of different users are still spread across all shard copies.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">_only_local</code> preference guarantees only to use shard copies on the
local node, which is sometimes useful for troubleshooting. All other options do
not <em>fully</em> guarantee that any particular shard copies are used in a search,
and on a changing index this may mean that repeated searches may yield
different results if they are executed on different shard copies which are in
different refresh states.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-rescore"></a>Rescoring<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/rescore.asciidoc">edit</a></h3>
</div></div></div>
<p>Rescoring can help to improve precision by reordering just the top (eg
100 - 500) documents returned by the
<a class="xref" href="search-search.html#request-body-search-query"><code class="literal">query</code></a> and
<a class="xref" href="search-request-body.html#request-body-search-post-filter" title="Post filter"><code class="literal">post_filter</code></a> phases, using a
secondary (usually more costly) algorithm, instead of applying the
costly algorithm to all documents in the index.</p>
<p>A <code class="literal">rescore</code> request is executed on each shard before it returns its
results to be sorted by the node handling the overall search request.</p>
<p>Currently the rescore API has only one implementation: the query
rescorer, which uses a query to tweak the scoring. In the future,
alternative rescorers may be made available, for example, a pair-wise rescorer.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>An error will be thrown if an explicit <a class="xref" href="sort-search-results.html" title="Sort search results"><code class="literal">sort</code></a>
(other than <code class="literal">_score</code> in descending order) is provided with a <code class="literal">rescore</code> query.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>when exposing pagination to your users, you should not change
<code class="literal">window_size</code> as you step through each page (by passing different
<code class="literal">from</code> values) since that can alter the top hits causing results to
confusingly shift as the user steps through pages.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_query_rescorer"></a>Query rescorer<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/rescore.asciidoc">edit</a></h4>
</div></div></div>
<p>The query rescorer executes a second query only on the Top-K results
returned by the <a class="xref" href="search-search.html#request-body-search-query"><code class="literal">query</code></a> and
<a class="xref" href="search-request-body.html#request-body-search-post-filter" title="Post filter"><code class="literal">post_filter</code></a> phases. The
number of docs which will be examined on each shard can be controlled by
the <code class="literal">window_size</code> parameter, which defaults to 10.</p>
<p>By default the scores from the original query and the rescore query are
combined linearly to produce the final <code class="literal">_score</code> for each document. The
relative importance of the original query and of the rescore query can
be controlled with the <code class="literal">query_weight</code> and <code class="literal">rescore_query_weight</code>
respectively. Both default to <code class="literal">1</code>.</p>
<p>For example:</p>
<a id="829a40d484c778a8c58340c7bf09e1d8"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /_search
{
   "query" : {
      "match" : {
         "message" : {
            "operator" : "or",
            "query" : "the quick brown"
         }
      }
   },
   "rescore" : {
      "window_size" : 50,
      "query" : {
         "rescore_query" : {
            "match_phrase" : {
               "message" : {
                  "query" : "the quick brown",
                  "slop" : 2
               }
            }
         },
         "query_weight" : 0.7,
         "rescore_query_weight" : 1.2
      }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2062.console"></div>
<p>The way the scores are combined can be controlled with the <code class="literal">score_mode</code>:</p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Score Mode</th>
<th align="left" valign="top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p><code class="literal">total</code></p></td>
<td align="left" valign="top"><p>Add the original score and the rescore query score.  The default.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">multiply</code></p></td>
<td align="left" valign="top"><p>Multiply the original score by the rescore query score.  Useful
for <a class="xref" href="query-dsl-function-score-query.html" title="Function score query"><code class="literal">function query</code></a> rescores.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">avg</code></p></td>
<td align="left" valign="top"><p>Average the original score and the rescore query score.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">max</code></p></td>
<td align="left" valign="top"><p>Take the max of original score and the rescore query score.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">min</code></p></td>
<td align="left" valign="top"><p>Take the min of the original score and the rescore query score.</p></td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_multiple_rescores"></a>Multiple Rescores<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/rescore.asciidoc">edit</a></h4>
</div></div></div>
<p>It is also possible to execute multiple rescores in sequence:</p>
<a id="9334ccd09548b585cd637d7c66c5ae65"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /_search
{
   "query" : {
      "match" : {
         "message" : {
            "operator" : "or",
            "query" : "the quick brown"
         }
      }
   },
   "rescore" : [ {
      "window_size" : 100,
      "query" : {
         "rescore_query" : {
            "match_phrase" : {
               "message" : {
                  "query" : "the quick brown",
                  "slop" : 2
               }
            }
         },
         "query_weight" : 0.7,
         "rescore_query_weight" : 1.2
      }
   }, {
      "window_size" : 10,
      "query" : {
         "score_mode": "multiply",
         "rescore_query" : {
            "function_score" : {
               "script_score": {
                  "script": {
                    "source": "Math.log10(doc.count.value + 2)"
                  }
               }
            }
         }
      }
   } ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2063.console"></div>
<p>The first one gets the results of the query then the second one gets the
results of the first, etc.  The second rescore will "see" the sorting done
by the first rescore so it is possible to use a large window on the first
rescore to pull documents into a smaller window for the second rescore.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-script-fields"></a>Script Fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="search-fields.html#script-fields" title="Script fields">Script fields</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-scroll"></a>Scroll<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="paginate-search-results.html#scroll-search-results" title="Scroll search results">Scroll search results</a>.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_clear_scroll_api"></a>Clear scroll API<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h4>
</div></div></div>
<p>See <a class="xref" href="clear-scroll-api.html" title="Clear scroll API">Clear scroll</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="sliced-scroll"></a>Sliced scroll<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h4>
</div></div></div>
<p>See <a class="xref" href="paginate-search-results.html#slice-scroll" title="Sliced Scroll">Sliced Scroll</a>.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-search-after"></a>Search After<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="paginate-search-results.html#search-after" title="Search after">Search after</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-search-type"></a>Search Type<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/search-type.asciidoc">edit</a></h3>
</div></div></div>
<p>There are different execution paths that can be done when executing a
distributed search. The distributed search operation needs to be
scattered to all the relevant shards and then all the results are
gathered back. When doing scatter/gather type execution, there are
several ways to do that, specifically with search engines.</p>
<p>One of the questions when executing a distributed search is how many
results to retrieve from each shard. For example, if we have 10 shards,
the 1st shard might hold the most relevant results from 0 till 10, with
other shards results ranking below it. For this reason, when executing a
request, we will need to get results from 0 till 10 from all shards,
sort them, and then return the results if we want to ensure correct
results.</p>
<p>Another question, which relates to the search engine, is the fact that each
shard stands on its own. When a query is executed on a specific shard,
it does not take into account term frequencies and other search engine
information from the other shards. If we want to support accurate
ranking, we would need to first gather the term frequencies from all
shards to calculate global term frequencies, then execute the query on
each shard using these global frequencies.</p>
<p>Also, because of the need to sort the results, getting back a large
document set, or even scrolling it, while maintaining the correct sorting
behavior can be a very expensive operation. For large result set
scrolling, it is best to sort by <code class="literal">_doc</code> if the order in which documents
are returned is not important.</p>
<p>Elasticsearch is very flexible and allows to control the type of search
to execute on a <span class="strong strong"><strong>per search request</strong></span> basis. The type can be configured
by setting the <span class="strong strong"><strong>search_type</strong></span> parameter in the query string. The types
are:</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="query-then-fetch"></a>Query Then Fetch<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/search-type.asciidoc">edit</a></h4>
</div></div></div>
<p>Parameter value: <span class="strong strong"><strong>query_then_fetch</strong></span>.</p>
<p>The request is processed in two phases. In the first phase, the query
is forwarded to <span class="strong strong"><strong>all involved shards</strong></span>. Each shard executes the search
and generates a sorted list of results, local to that shard. Each
shard returns <span class="strong strong"><strong>just enough information</strong></span> to the coordinating node
to allow it to merge and re-sort the shard level results into a globally
sorted set of results, of maximum length <code class="literal">size</code>.</p>
<p>During the second phase, the coordinating node requests the document
content (and highlighted snippets, if any) from <span class="strong strong"><strong>only the relevant
shards</strong></span>.</p>
<a id="68717fc9d2a29fc6b688892f2e49c126"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my-index-000001/_search?search_type=query_then_fetch</pre>
</div>
<div class="console_widget" data-snippet="snippets/2064.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>This is the default setting, if you do not specify a <code class="literal">search_type</code>
      in your request.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="dfs-query-then-fetch"></a>Dfs, Query Then Fetch<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/search-type.asciidoc">edit</a></h4>
</div></div></div>
<p>Parameter value: <span class="strong strong"><strong>dfs_query_then_fetch</strong></span>.</p>
<p>Same as "Query Then Fetch", except for an initial scatter phase which
goes and computes the distributed term frequencies for more accurate
scoring.</p>
<a id="ef5dc51fc3f0cd3a3034b4305370993d"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my-index-000001/_search?search_type=dfs_query_then_fetch</pre>
</div>
<div class="console_widget" data-snippet="snippets/2065.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-sort"></a>Sort<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="sort-search-results.html" title="Sort search results"><em>Sort search results</em></a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-source-filtering"></a>Source filtering<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="search-fields.html#source-filtering" title="Source filtering">Source filtering</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-stored-fields"></a>Stored fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request-body.asciidoc">edit</a></h3>
</div></div></div>
<p>See <a class="xref" href="search-fields.html#stored-fields" title="Stored fields">Stored fields</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="request-body-search-track-total-hits"></a>Track total hits<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/search/request/track-total-hits.asciidoc">edit</a></h3>
</div></div></div>
<p>Generally the total hit count can&#8217;t be computed accurately without visiting all
matches, which is costly for queries that match lots of documents. The
<code class="literal">track_total_hits</code> parameter allows you to control how the total number of hits
should be tracked.
Given that it is often enough to have a lower bound of the number of hits,
such as "there are at least 10000 hits", the default is set to <code class="literal">10,000</code>.
This means that requests will count the total hit accurately up to <code class="literal">10,000</code> hits.
It&#8217;s is a good trade off to speed up searches if you don&#8217;t need the accurate number
of hits after a certain threshold.</p>
<p>When set to <code class="literal">true</code> the search response will always track the number of hits that
match the query accurately (e.g. <code class="literal">total.relation</code> will always be equal to <code class="literal">"eq"</code>
when <code class="literal">track_total_hits</code> is set to true). Otherwise the <code class="literal">"total.relation"</code> returned
in the <code class="literal">"total"</code> object in the search response determines how the <code class="literal">"total.value"</code>
should be interpreted. A value of <code class="literal">"gte"</code> means that the <code class="literal">"total.value"</code> is a
lower bound of the total hits that match the query and a value of <code class="literal">"eq"</code> indicates
that <code class="literal">"total.value"</code> is the accurate count.</p>
<a id="143ce25e5f85074528df45c3a67c44fd"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my-index-000001/_search
{
  "track_total_hits": true,
    "query": {
      "match" : {
        "user.id" : "elkbee"
      }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2066.console"></div>
<p>... returns:</p>
<a id="1a819d4ed60e70be8e8a47bfd9314bc6"></a>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "_shards": ...
  "timed_out": false,
  "took": 100,
  "hits": {
    "max_score": 1.0,
    "total" : {
      "value": 2048,    <a id="CO623-1"></a><i class="conum" data-value="1"></i>
      "relation": "eq"  <a id="CO623-2"></a><i class="conum" data-value="2"></i>
    },
    "hits": ...
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO623-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The total number of hits that match the query.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO623-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The count is accurate (e.g. <code class="literal">"eq"</code> means equals).</p>
</td>
</tr>
</table>
</div>
<p>It is also possible to set <code class="literal">track_total_hits</code> to an integer.
For instance the following query will accurately track the total hit count that match
the query up to 100 documents:</p>
<a id="d66e2b4d1931bf88c72e74670156e43f"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my-index-000001/_search
{
  "track_total_hits": 100,
  "query": {
    "match": {
      "user.id": "elkbee"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2067.console"></div>
<p>The <code class="literal">hits.total.relation</code> in the response will indicate if the
value returned in <code class="literal">hits.total.value</code> is accurate (<code class="literal">"eq"</code>) or a lower
bound of the total (<code class="literal">"gte"</code>).</p>
<p>For instance the following response:</p>
<a id="4ebb074ca279515decc21f2c0ecf312a"></a>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "_shards": ...
  "timed_out": false,
  "took": 30,
  "hits": {
    "max_score": 1.0,
    "total": {
      "value": 42,         <a id="CO624-1"></a><i class="conum" data-value="1"></i>
      "relation": "eq"     <a id="CO624-2"></a><i class="conum" data-value="2"></i>
    },
    "hits": ...
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO624-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>42 documents match the query</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO624-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>and the count is accurate (<code class="literal">"eq"</code>)</p>
</td>
</tr>
</table>
</div>
<p>... indicates that the number of hits returned in the <code class="literal">total</code>
is accurate.</p>
<p>If the total number of hits that match the query is greater than the
value set in <code class="literal">track_total_hits</code>, the total hits in the response
will indicate that the returned value is a lower bound:</p>
<a id="6e51155699eb785b5f7bad3a3ce44dbf"></a>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "_shards": ...
  "hits": {
    "max_score": 1.0,
    "total": {
      "value": 100,         <a id="CO625-1"></a><i class="conum" data-value="1"></i>
      "relation": "gte"     <a id="CO625-2"></a><i class="conum" data-value="2"></i>
    },
    "hits": ...
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO625-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>There are at least 100 documents that match the query</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO625-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>This is a lower bound (<code class="literal">"gte"</code>).</p>
</td>
</tr>
</table>
</div>
<p>If you don&#8217;t need to track the total number of hits at all you can improve query
times by setting this option to <code class="literal">false</code>:</p>
<a id="1302e24b0476e0e9af7a2c890edf9f62"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET my-index-000001/_search
{
  "track_total_hits": false,
  "query": {
    "match": {
      "user.id": "elkbee"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/2068.console"></div>
<p>... returns:</p>
<a id="8519b22e360fe7b828d97061b72be5ec"></a>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "_shards": ...
  "timed_out": false,
  "took": 10,
  "hits": {             <a id="CO626-1"></a><i class="conum" data-value="1"></i>
    "max_score": 1.0,
    "hits": ...
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO626-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The total number of hits is unknown.</p>
</td>
</tr>
</table>
</div>
<p>Finally you can force an accurate count by setting <code class="literal">"track_total_hits"</code>
to <code class="literal">true</code> in the request.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-search.html">« Search API</a>
</span>
<span class="next">
<a href="async-search.html">Async search »</a>
</span>
</div>
</div>
</body>
</html>
