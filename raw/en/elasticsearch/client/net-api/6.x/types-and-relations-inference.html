<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Type and Relation names inference
        | Elasticsearch.Net and NEST: the .NET clients [6.x]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch.Net and NEST: the .NET clients [6.x]" /><link rel="up" href="nest-conventions.html" title="Conventions" /><link rel="prev" href="index-name-inference.html" title="Index name inference" /><link rel="next" href="ids-inference.html" title="Ids inference" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Clients/.Net/6.x" /><meta xmlns="" name="DC.subject" content="Clients" /><meta xmlns="" name="DC.identifier" content="6.x" /></head><body><div xmlns="" class="page_header">You are looking at documentation for an older release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch.Net and NEST:  the .NET clients
      [6.x]
    </a></span> » <span class="breadcrumb-link"><a href="nest.html">NEST - High level client</a></span> » <span class="breadcrumb-link"><a href="nest-conventions.html">Conventions</a></span> » <span class="breadcrumb-node">Type and Relation names inference</span></div><div xmlns="" class="navheader"><span class="prev"><a href="index-name-inference.html">
              « 
              Index name inference</a>
           
        </span><span class="next">
           
          <a href="ids-inference.html">Ids inference
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="types-and-relations-inference"></a>Type and Relation names inference<a xmlns="" href="https://github.com/elastic/elasticsearch-net/edit/6.x/docs/client-concepts/high-level/inference/types-and-relations-inference.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>Type names are resolved in NEST by default, by lowercasing the CLR type name</p><div xmlns="" class="pre_wrapper lang-csharp"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-csharp">var settings = new ConnectionSettings();
var resolver = new TypeNameResolver(settings);
var type = resolver.Resolve&lt;Project&gt;();
type.Should().Be("project");</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="elasticsearchtype-attribute"></a>Applying a type name with <code class="literal">ElasticsearchTypeAttribute</code><a xmlns="" href="https://github.com/elastic/elasticsearch-net/edit/6.x/docs/client-concepts/high-level/inference/types-and-relations-inference.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>A type name can be applied for a CLR type, using the Name property on <code class="literal">ElasticsearchTypeAttribute</code></p><div xmlns="" class="pre_wrapper lang-csharp"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-csharp">[ElasticsearchType(Name = "attributed_project")]
public class AttributedProject { }

var settings = new ConnectionSettings();
var resolver = new TypeNameResolver(settings);
var type = resolver.Resolve&lt;AttributedProject&gt;();
type.Should().Be("attributed_project");</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="datacontract-attribute"></a>Applying a type name with <code class="literal">DataContractAttribute</code><a xmlns="" href="https://github.com/elastic/elasticsearch-net/edit/6.x/docs/client-concepts/high-level/inference/types-and-relations-inference.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>Similarly to <a class="link" href="types-and-relations-inference.html#elasticsearchtype-attribute" title="Applying a type name with ElasticsearchTypeAttribute"><code class="literal">ElasticsearchTypeAttribute</code></a>, a type name can be applied for a
CLR type, using the Name property on <code class="literal">System.Runtime.Serialization.DataContractAttribute</code></p><div xmlns="" class="pre_wrapper lang-csharp"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-csharp">[DataContract(Name = "data_contract_project")]
public class DataContractProject { }

var settings = new ConnectionSettings();
var resolver = new TypeNameResolver(settings);
var type = resolver.Resolve&lt;DataContractProject&gt;();
type.Should().Be("data_contract_project");</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="default-type-name"></a>Default type name<a xmlns="" href="https://github.com/elastic/elasticsearch-net/edit/6.x/docs/client-concepts/high-level/inference/types-and-relations-inference.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>With Elasticsearch 6.x, you can only have a single type per index and in the long run types will be
phased out entirely.
The need to tag types is no longer necessary, so in many cases it makes sense to use a single fixed type,
like <code class="literal">doc</code></p><div xmlns="" class="pre_wrapper lang-csharp"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-csharp">var settings = new ConnectionSettings().DefaultTypeName("doc");
var resolver = new TypeNameResolver(settings);
var type = resolver.Resolve&lt;Project&gt;();
type.Should().Be("doc");</pre></div><p>With such a setting in place, all CLR types will resolve to <code class="literal">doc</code> as the type name to use in Elasticsearch.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="type-name-inferrer"></a>Override type name inferrer<a xmlns="" href="https://github.com/elastic/elasticsearch-net/edit/6.x/docs/client-concepts/high-level/inference/types-and-relations-inference.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>You can provide a delegate to override the default type name inferrer for types</p><div xmlns="" class="pre_wrapper lang-csharp"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-csharp">var settings = new ConnectionSettings()
    .DefaultTypeNameInferrer(t=&gt;t.Name.ToLower() + "-suffix");
var resolver = new TypeNameResolver(settings);
var type = resolver.Resolve&lt;Project&gt;();
type.Should().Be("project-suffix");</pre></div><h3><a id="relation-names"></a>Relation names<a xmlns="" href="https://github.com/elastic/elasticsearch-net/edit/6.x/docs/client-concepts/high-level/inference/types-and-relations-inference.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3><p>Prior to Elasticsearch 6.x you could have multiple types per index. They acted as a discrimatory column but were often
confused with tables. The fact that the mapping API’s treated them as seperate entities did not help.</p><p>The general guideline has always been to use a single type per index. Starting from 6.x this is also enforced.
Some features still need to store multiple types in a single index such as Parent/Child join relations.</p><p>Both <code class="literal">Parent</code> and <code class="literal">Child</code> will need to have resolve to the same typename to be indexed into the same index.</p><p>Therefore in 6.x we need a different type that translates a CLR type to a join relation. This can be configured seperately
using <code class="literal">.RelationName()</code></p><div xmlns="" class="pre_wrapper lang-csharp"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-csharp">var settings = new ConnectionSettings()
    .DefaultMappingFor&lt;CommitActivity&gt;(m =&gt; m
        .IndexName("projects-and-commits")
        .TypeName("doc")
        .RelationName("commits")
    )
    .DefaultMappingFor&lt;Project&gt;(m =&gt; m
        .IndexName("projects-and-commits")
        .TypeName("doc")
        .RelationName("projects")
    );

var resolver = new RelationNameResolver(settings);
var relation = resolver.Resolve&lt;Project&gt;();
relation.Should().Be("projects");

relation = resolver.Resolve&lt;CommitActivity&gt;();
relation.Should().Be("commits");</pre></div><p><code class="literal">RelationName</code> uses the <code class="literal">DefaultTypeNameInferrer</code> to translate CLR types to a string representation.</p><p>Explicit <code class="literal">TypeName</code> configuration does not affect how the default relation for the CLR type
is represented though</p><div xmlns="" class="pre_wrapper lang-csharp"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-csharp">var settings = new ConnectionSettings()
    .DefaultMappingFor&lt;Project&gt;(m =&gt; m
        .IndexName("projects-and-commits")
        .TypeName("doc")
    );

var resolver = new RelationNameResolver(settings);
var relation = resolver.Resolve&lt;Project&gt;();
relation.Should().Be("project");</pre></div></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="index-name-inference.html">
              « 
              Index name inference</a>
           
        </span><span class="next">
           
          <a href="ids-inference.html">Ids inference
               »
            </a></span></div></body></html>