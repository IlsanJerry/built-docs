<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">One Big User
        | Elasticsearch: The Definitive Guide [master]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [master]" /><link rel="up" href="scale.html" title="Designing for Scale" /><link rel="prev" href="faking-it.html" title="Faking Index per User with Aliases" /><link rel="next" href="finite-scale.html" title="Scale Is Not Infinite" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/master" /><meta xmlns="" name="DC.subject" content="Elasticsearch" /><meta xmlns="" name="DC.identifier" content="master" /><meta xmlns="" name="robots" content="noindex,nofollow" /></head><body><div xmlns="" class="page_header">This information may not apply to the latest version of Elasticsearch.
For the most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [master]
    </a></span> » <span class="breadcrumb-link"><a href="modeling-your-data.html">Modeling Your Data</a></span> » <span class="breadcrumb-link"><a href="scale.html">Designing for Scale</a></span> » <span class="breadcrumb-node">One Big User</span></div><div xmlns="" class="navheader"><span class="prev"><a href="faking-it.html">
              « 
              Faking Index per User with Aliases</a>
           
        </span><span class="next">
           
          <a href="finite-scale.html">Scale Is Not Infinite
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="one-big-user"></a>One Big User<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/master/410_Scaling/75_One_big_user.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>Big, popular forums start out as small forums.<a id="id-1.9.6.19.2.1" class="indexterm"></a>
<a id="id-1.9.6.19.2.2" class="indexterm"></a>  One day we will find that one
shard in our shared index is doing a lot more work than the other shards,
because it holds the documents for a forum that has become very popular. That
forum now needs its own index.</p><p>The index aliases that we’re using to fake an index per user give us a clean
migration path for the big forum.<a id="id-1.9.6.19.3.1" class="indexterm"></a>
<a id="id-1.9.6.19.3.2" class="indexterm"></a>
<a id="id-1.9.6.19.3.3" class="indexterm"></a></p><p>The first step is to create a new index dedicated to the forum, and with the
appropriate number of shards to allow for expected growth:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">PUT /baking_v1
{
  "settings": {
    "number_of_shards": 3
  }
}</pre></div><p>The next step is to migrate the data from the shared index into the dedicated
index, which can be done using a <a class="link" href="scroll.html" title="Scroll"><code class="literal">scroll</code></a> query and the
<a class="link" href="bulk.html" title="Cheaper in Bulk"><code class="literal">bulk</code> API</a>.  As soon as the migration is finished, the index alias
can be updated to point to the new index:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">POST /_aliases
{
  "actions": [
    { "remove": { "alias": "baking", "index": "forums"    }},
    { "add":    { "alias": "baking", "index": "baking_v1" }}
  ]
}</pre></div><p>Updating the alias is atomic; it’s like throwing a switch.  Your application
continues talking to the <code class="literal">baking</code> API and is completely unaware that it now
points to a new dedicated index.</p><p>The dedicated index no longer needs the filter or the routing values. We can
just rely on the default sharding that Elasticsearch does using each
document’s <code class="literal">_id</code> field.</p><p>The last step is to remove the old documents from the shared index, which can
be done by searching using the original routing value and forum ID and performing
a bulk delete.</p><p>The beauty of this index-per-user model is that it allows you to reduce
resources, keeping costs low, while still giving you the flexibility to scale
out when necessary, and with zero downtime.</p></div><div xmlns="" class="navfooter"><span class="prev"><a href="faking-it.html">
              « 
              Faking Index per User with Aliases</a>
           
        </span><span class="next">
           
          <a href="finite-scale.html">Scale Is Not Infinite
               »
            </a></span></div></body></html>