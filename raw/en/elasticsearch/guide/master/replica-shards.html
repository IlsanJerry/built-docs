<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Replica Shards
        | Elasticsearch: The Definitive Guide [master]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [master]" /><link rel="up" href="scale.html" title="Designing for Scale" /><link rel="prev" href="capacity-planning.html" title="Capacity Planning" /><link rel="next" href="multiple-indices.html" title="Multiple Indices" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/master" /><meta xmlns="" name="DC.subject" content="Elasticsearch" /><meta xmlns="" name="DC.identifier" content="master" /><meta xmlns="" name="robots" content="noindex,nofollow" /></head><body><div xmlns="" class="page_header">This information may not apply to the latest version of Elasticsearch.
For the most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [master]
    </a></span> » <span class="breadcrumb-link"><a href="modeling-your-data.html">Modeling Your Data</a></span> » <span class="breadcrumb-link"><a href="scale.html">Designing for Scale</a></span> » <span class="breadcrumb-node">Replica Shards</span></div><div xmlns="" class="navheader"><span class="prev"><a href="capacity-planning.html">
              « 
              Capacity Planning</a>
           
        </span><span class="next">
           
          <a href="multiple-indices.html">Multiple Indices
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="replica-shards"></a>Replica Shards<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/master/410_Scaling/35_Replica_shards.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>Up until now we have spoken only about primary shards, but we have another
tool in our belt: replica shards.<a id="id-1.9.6.11.2.1" class="indexterm"></a>
<a id="id-1.9.6.11.2.2" class="indexterm"></a><a id="id-1.9.6.11.2.3" class="indexterm"></a>
<a id="id-1.9.6.11.2.4" class="indexterm"></a><a id="id-1.9.6.11.2.5" class="indexterm"></a>  The main purpose of replicas is for
failover, as discussed in <a class="xref" href="distributed-cluster.html" title="Life Inside a Cluster"><em>Life Inside a Cluster</em></a>: if the node holding a
primary shard dies, a replica is promoted to the role of primary.</p><p>At index time, a replica shard does the same amount of work as the primary
shard.  New documents are first indexed on the primary and then on any
replicas.  Increasing the number of replicas does not change the capacity of
the index.</p><p>However, replica shards can serve read requests.  If, as is often the case,
your index is search heavy, you can increase search performance by increasing
the number of replicas, but only if you also <span class="emphasis"><em>add extra hardware</em></span>.</p><p>Let’s return to our example of an index with two primary shards.  We increased
capacity of the index by adding a second node. Adding more nodes would not
help us to add indexing capacity, but we could take advantage of the extra
hardware at search time by increasing the number of replicas:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">PUT /my_index/_settings
{
  "number_of_replicas": 1
}</pre></div><p>Having two primary shards, plus a replica of each primary, would give us a
total of four shards: one for each node, as shown in <a class="xref" href="replica-shards.html#img-four-nodes" title="Figure 51. An index with two primary shards and one replica can scale out across four nodes">Figure 51, “An index with two primary shards and one replica can scale out across four nodes”</a>.</p><div class="figure"><a id="img-four-nodes"></a><p class="title"><strong>Figure 51. An index with two primary shards and one replica can scale out across four nodes</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/elas_4403.png" alt="An index with two primary shards and one replica can scale out across four nodes" /></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_balancing_load_with_replicas"></a>Balancing Load with Replicas<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/master/410_Scaling/35_Replica_shards.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>Search performance depends on the response times of the slowest node, so it is a good idea to try to balance out the load across all nodes.<a id="id-1.9.6.11.9.2.1" class="indexterm"></a>
<a id="id-1.9.6.11.9.2.2" class="indexterm"></a><a id="id-1.9.6.11.9.2.3" class="indexterm"></a> If we
added just one extra node instead of two, we would end up with two nodes having one shard each, and one node doing double the work with two shards.</p><p>We can even things out by adjusting the number of replicas.  By allocating two
replicas instead of one, we end up with a total of six shards, which can be
evenly divided between three nodes, as shown in <a class="xref" href="replica-shards.html#img-three-nodes" title="Figure 52. Adjust the number of replicas to balance the load between nodes">Figure 52, “Adjust the number of replicas to balance the load between nodes”</a>:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">PUT /my_index/_settings
{
  "number_of_replicas": 2
}</pre></div><p>As a bonus, we have also increased our availability.  We can now afford to
lose two nodes and still have a copy of all our data.</p><div class="figure"><a id="img-three-nodes"></a><p class="title"><strong>Figure 52. Adjust the number of replicas to balance the load between nodes</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/elas_4404.png" alt="Adjust the number of replicas to balance the load between nodes" /></div></div></div><div xmlns="" class="note admon"><div class="icon"><img alt="Note" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">The fact that node 3 holds two replicas and no primaries is not
important.  Replicas and primaries do the same amount of work; they just play
slightly different roles.  There is no need to ensure that primaries are
distributed evenly across all nodes.</p></div></div></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="capacity-planning.html">
              « 
              Capacity Planning</a>
           
        </span><span class="next">
           
          <a href="multiple-indices.html">Multiple Indices
               »
            </a></span></div></body></html>