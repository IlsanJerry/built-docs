<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Term-Based Versus Full-Text
        | Elasticsearch: The Definitive Guide [master]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [master]" /><link rel="up" href="full-text-search.html" title="Full-Text Search" /><link rel="prev" href="full-text-search.html" title="Full-Text Search" /><link rel="next" href="match-query.html" title="The match Query" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/master" /><meta xmlns="" name="DC.subject" content="Elasticsearch" /><meta xmlns="" name="DC.identifier" content="master" /><meta xmlns="" name="robots" content="noindex,nofollow" /></head><body><div xmlns="" class="page_header">This information may not apply to the latest version of Elasticsearch.
For the most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [master]
    </a></span> » <span class="breadcrumb-link"><a href="search-in-depth.html">Search in Depth</a></span> » <span class="breadcrumb-link"><a href="full-text-search.html">Full-Text Search</a></span> » <span class="breadcrumb-node">Term-Based Versus Full-Text</span></div><div xmlns="" class="navheader"><span class="prev"><a href="full-text-search.html">
              « 
              Full-Text Search</a>
           
        </span><span class="next">
           
          <a href="match-query.html">The match Query
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="term-vs-full-text"></a>Term-Based Versus Full-Text<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/master/100_Full_Text_Search/00_Intro.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>While all queries perform some sort of relevance calculation, not all queries
have an analysis phase.<a id="id-1.5.4.6.2.1" class="indexterm"></a>
<a id="id-1.5.4.6.2.2" class="indexterm"></a><a id="id-1.5.4.6.2.3" class="indexterm"></a> Besides specialized queries like the <code class="literal">bool</code> or
<code class="literal">function_score</code> queries, which don’t operate on text at all, textual queries can
be broken down into two families:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
Term-based queries
</span></dt><dd><p class="simpara">Queries like the <code class="literal">term</code> or <code class="literal">fuzzy</code> queries are low-level queries that have no
analysis phase.<a id="id-1.5.4.6.3.1.2.1.3" class="indexterm"></a> They operate on a single term. A <code class="literal">term</code> query for the term
<code class="literal">Foo</code> looks for that <span class="emphasis"><em>exact term</em></span> in the inverted index and calculates the
TF/IDF relevance <code class="literal">_score</code> for each document that contains the term.</p><p class="simpara">It is important to remember that the <code class="literal">term</code> query looks in the inverted index
for the exact term only; it won’t match any variants like <code class="literal">foo</code> or
<code class="literal">FOO</code>.  It doesn’t matter how the term came to be in the index, just that it
is.  If you were to index <code class="literal">["Foo","Bar"]</code> into an exact value <code class="literal">not_analyzed</code>
field, or <code class="literal">Foo Bar</code> into an analyzed field with the <code class="literal">whitespace</code> analyzer,
both would result in having the two terms <code class="literal">Foo</code> and <code class="literal">Bar</code> in the inverted
index.</p></dd><dt><span class="term">
Full-text queries
</span></dt><dd><p class="simpara">Queries like the <code class="literal">match</code> or <code class="literal">query_string</code> queries are high-level queries
that understand the mapping of a field:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
If you use them to query a <code class="literal">date</code> or <code class="literal">integer</code> field, they will treat the
   query string as a date or integer, respectively.
</li><li class="listitem">
If you query an exact value (<code class="literal">not_analyzed</code>) string field,<a id="id-1.5.4.6.3.2.2.2.2.1.2" class="indexterm"></a>
<a id="id-1.5.4.6.3.2.2.2.2.1.3" class="indexterm"></a> they will treat
   the whole query string as a single term.
</li><li class="listitem">
But if you query a full-text (<code class="literal">analyzed</code>) field,<a id="id-1.5.4.6.3.2.2.2.3.1.2" class="indexterm"></a>
<a id="id-1.5.4.6.3.2.2.2.3.1.3" class="indexterm"></a> they will first pass the
  query string through the appropriate analyzer to produce the list of terms
  to be queried.
</li></ul></div><p class="simpara">Once the query has assembled a list of terms, it executes the appropriate
low-level query for each of these terms, and then combines  their results to
produce the final relevance score for each document.</p><p class="simpara">We will discuss this process in more detail in the following chapters.</p></dd></dl></div><p>You seldom need to use the term-based queries directly. Usually you want to
query full text, not individual terms, and this is easier to do with the
high-level full-text queries (which end up using term-based queries
internally).</p><div xmlns="" class="note admon"><div class="icon"><img alt="Note" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">If you do find yourself wanting to use a query on an exact value
<code class="literal">not_analyzed</code> field, <a id="id-1.5.4.6.5.1.2" class="indexterm"></a>
<a id="id-1.5.4.6.5.1.3" class="indexterm"></a>think
about whether you really want a scoring query, or if a non-scoring query might be better.</p><p xmlns="http://www.w3.org/1999/xhtml">Single-term queries usually represent binary yes/no questions and are
almost always better expressed as a <a id="id-1.5.4.6.5.2.1" class="indexterm"></a>
<a id="id-1.5.4.6.5.2.2" class="indexterm"></a>
<a id="id-1.5.4.6.5.2.3" class="indexterm"></a>
filter, so that they can benefit from <a class="link" href="filter-caching.html" title="All About Caching">caching</a>:</p><div class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query": {
        "constant_score": {
            "filter": {
                "term": { "gender": "female" }
            }
        }
    }
}</pre></div></div></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="full-text-search.html">
              « 
              Full-Text Search</a>
           
        </span><span class="next">
           
          <a href="match-query.html">The match Query
               »
            </a></span></div></body></html>