<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Query-Time Search-as-You-Type
        | Elasticsearch: The Definitive Guide [master]
      | Elastic
    </title><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [master]" /><link rel="up" href="partial-matching.html" title="Partial Matching" /><link rel="prev" href="_wildcard_and_regexp_queries.html" title="wildcard and regexp Queries" /><link rel="next" href="_index_time_optimizations.html" title="Index-Time Optimizations" /><meta name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/master" /><meta name="DC.subject" content="Elasticsearch" /><meta name="DC.identifier" content="master" /><meta name="robots" content="noindex,nofollow" /></head><body><div class="page_header">This information may not apply to the latest version of Elasticsearch.
For the most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [master]
    </a></span> » <span class="breadcrumb-link"><a href="search-in-depth.html">Search in Depth</a></span> » <span class="breadcrumb-link"><a href="partial-matching.html">Partial Matching</a></span> » <span class="breadcrumb-node">Query-Time Search-as-You-Type</span></div><div class="navheader"><span class="prev"><a href="_wildcard_and_regexp_queries.html">
              « 
              wildcard and regexp Queries</a>
           
        </span><span class="next">
           
          <a href="_index_time_optimizations.html">Index-Time Optimizations
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="_query_time_search_as_you_type"></a>Query-Time Search-as-You-Type</h2></div></div></div><p>Leaving postcodes behind, let’s take a look at how prefix matching can help
with full-text queries. <a id="id-1.5.7.14.2.1" class="indexterm"></a> Users have become accustomed to seeing search results
before they have finished typing their query—​so-called <span class="emphasis"><em>instant search</em></span>, or
<span class="emphasis"><em>search-as-you-type</em></span>. <a id="id-1.5.7.14.2.4" class="indexterm"></a><a id="id-1.5.7.14.2.5" class="indexterm"></a> Not only do users receive their search results in less
time, but we can guide them toward results that actually exist in our index.</p><p>For instance, if a user types in <code class="literal">johnnie walker bl</code>, we would like to show results for Johnnie Walker Black Label and Johnnie Walker Blue
Label before they can finish typing their query.</p><p>As always, there are more ways than one to skin a cat! We will start by
looking at the way that is simplest to implement.  You don’t need to prepare your
data in any way; you can implement <span class="emphasis"><em>search-as-you-type</em></span> at query time on any
full-text field.</p><p>In <a class="xref" href="phrase-matching.html" title="Phrase Matching">Phrase Matching</a>, we introduced the <code class="literal">match_phrase</code> query, which matches
all the specified words in the same positions relative to each other.  For-query time search-as-you-type, we can use a specialization of this query,
called <a id="id-1.5.7.14.5.3" class="indexterm"></a><a id="id-1.5.7.14.5.4" class="indexterm"></a>the <code class="literal">match_phrase_prefix</code> query:</p><div class="pre_wrapper lang-sense"><pre class="programlisting prettyprint lang-sense">{
    "match_phrase_prefix" : {
        "brand" : "johnnie walker bl"
    }
}</pre></div><div class="sense_widget" data-snippet="snippets/130_Partial_Matching/20_Match_phrase_prefix.json"></div><p>This query behaves in the same way as the <code class="literal">match_phrase</code> query, except that it
treats the last word in the query string as a prefix.  In other words, the
preceding example would look for the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="literal">johnnie</code></li><li class="listitem">Followed by <code class="literal">walker</code></li><li class="listitem">Followed by words beginning with <code class="literal">bl</code></li></ul></div><p>If you were to run this query through the <code class="literal">validate-query</code> API, it would
produce this explanation:</p><pre class="literallayout">"johnnie walker bl*"</pre><p>Like the <code class="literal">match_phrase</code> query, it accepts a <code class="literal">slop</code> parameter (see <a class="xref" href="slop.html" title="Mixing It Up">Mixing It Up</a>) to
make the word order and relative positions <a id="id-1.5.7.14.11.4" class="indexterm"></a><a id="id-1.5.7.14.11.5" class="indexterm"></a>somewhat less rigid:</p><div class="pre_wrapper lang-sense"><pre class="programlisting prettyprint lang-sense">{
    "match_phrase_prefix" : {
        "brand" : {
            "query": "walker johnnie bl", <a id="CO94-1"></a><i class="conum" data-value="1"></i>
            "slop":  10
        }
    }
}</pre></div><div class="sense_widget" data-snippet="snippets/130_Partial_Matching/20_Match_phrase_prefix.json"></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO94-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>Even though the words are in the wrong order, the query still matches
because we have set a high enough <code class="literal">slop</code> value to allow some flexibility
in word positions.</p></td></tr></table></div><p>However, it is always only the last word in the query string that is treated
as a prefix.</p><p>Earlier, in <a class="xref" href="prefix-query.html" title="prefix Query">prefix Query</a>, we warned about the perils of the prefix—​how
<code class="literal">prefix</code> queries can be resource intensive.  The same is true in this
case.<a id="id-1.5.7.14.15.3" class="indexterm"></a>  A prefix of <code class="literal">a</code> could match hundreds of thousands of terms. Not only
would matching on this many terms be resource intensive, but it would also not be
useful to the user.</p><p>We can limit the impact <a id="id-1.5.7.14.16.1" class="indexterm"></a><a id="id-1.5.7.14.16.2" class="indexterm"></a>of the prefix expansion by setting <code class="literal">max_expansions</code> to
a reasonable number, such as 50:</p><div class="pre_wrapper lang-sense"><pre class="programlisting prettyprint lang-sense">{
    "match_phrase_prefix" : {
        "brand" : {
            "query":          "johnnie walker bl",
            "max_expansions": 50
        }
    }
}</pre></div><div class="sense_widget" data-snippet="snippets/130_Partial_Matching/20_Match_phrase_prefix.json"></div><p>The <code class="literal">max_expansions</code> parameter controls how many terms the prefix is allowed
to match.  It will find the first term starting with <code class="literal">bl</code> and keep collecting
terms (in alphabetical order) until it either runs out of terms with prefix
<code class="literal">bl</code>, or it has more terms than <code class="literal">max_expansions</code>.</p><p>Don’t forget that we have to run this query every time the user types another
character, so it needs to be fast.  If the first set of results isn’t what users are after, they’ll keep typing until they get the results that they want.</p></div><div class="navfooter"><span class="prev"><a href="_wildcard_and_regexp_queries.html">
              « 
              wildcard and regexp Queries</a>
           
        </span><span class="next">
           
          <a href="_index_time_optimizations.html">Index-Time Optimizations
               »
            </a></span></div></body></html>
