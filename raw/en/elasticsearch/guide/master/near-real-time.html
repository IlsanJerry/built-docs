<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Near Real-Time Search
        | Elasticsearch: The Definitive Guide [master]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [master]" /><link rel="up" href="inside-a-shard.html" title="Inside a Shard" /><link rel="prev" href="dynamic-indices.html" title="Dynamically Updatable Indices" /><link rel="next" href="translog.html" title="Making Changes Persistent" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/master" /><meta xmlns="" name="DC.subject" content="Elasticsearch" /><meta xmlns="" name="DC.identifier" content="master" /><meta xmlns="" name="robots" content="noindex,nofollow" /></head><body><div xmlns="" class="page_header">This information may not apply to the latest version of Elasticsearch.
For the most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [master]
    </a></span> » <span class="breadcrumb-link"><a href="getting-started.html">Getting Started</a></span> » <span class="breadcrumb-link"><a href="inside-a-shard.html">Inside a Shard</a></span> » <span class="breadcrumb-node">Near Real-Time Search</span></div><div xmlns="" class="navheader"><span class="prev"><a href="dynamic-indices.html">
              « 
              Dynamically Updatable Indices</a>
           
        </span><span class="next">
           
          <a href="translog.html">Making Changes Persistent
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="near-real-time"></a>Near Real-Time Search<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/master/075_Inside_a_shard/40_Near_real_time.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>With the development of per-segment search, the <a id="id-1.4.13.8.2.1" class="indexterm"></a>
<a id="id-1.4.13.8.2.2" class="indexterm"></a>delay between indexing a
document and making it visible to search dropped dramatically.  New documents
could be made searchable within minutes, but that still isn’t fast enough.</p><p>The bottleneck is the disk. <a id="id-1.4.13.8.3.1" class="indexterm"></a><a id="id-1.4.13.8.3.2" class="indexterm"></a><a id="id-1.4.13.8.3.3" class="indexterm"></a>
<a id="id-1.4.13.8.3.4" class="indexterm"></a> Commiting a new segment to disk requires an
<a class="ulink" href="http://en.wikipedia.org/wiki/Fsync" target="_top"><code class="literal">fsync</code></a> to ensure that the segment is
physically written to disk and that data will not be lost if there is a power
failure. But an <code class="literal">fsync</code> is costly; it cannot be performed every time a
document is indexed without a big performance hit.</p><p>What was needed was a more lightweight way to make new documents visible to
search, which meant removing <code class="literal">fsync</code> from the equation.</p><p>Sitting between Elasticsearch and the disk is the filesystem cache.<a id="id-1.4.13.8.5.1" class="indexterm"></a>  As before, documents in the in-memory indexing buffer (<a class="xref" href="near-real-time.html#img-pre-refresh" title="Figure 19. A Lucene index with new documents in the in-memory buffer">Figure 19, “A Lucene index with new documents in the in-memory buffer”</a>) are written to a new segment (<a class="xref" href="near-real-time.html#img-post-refresh" title="Figure 20. The buffer contents have been written to a segment, which is searchable, but is not yet commited">Figure 20, “The buffer contents have been written to a segment, which is searchable, but is not yet commited”</a>). But the new
segment is written to the filesystem cache first—which is cheap—and
only later is it flushed to disk—which is expensive.  But once a file is in
the cache, it can be opened and read, just like any other file.</p><div class="figure"><a id="img-pre-refresh"></a><p class="title"><strong>Figure 19. A Lucene index with new documents in the in-memory buffer</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/elas_1104.png" alt="A Lucene index with new documents in the in-memory buffer" /></div></div></div><p>Lucene allows new segments to be written and opened—making the documents
they contain visible to search—without performing a full commit. This is a
much lighter process than a commit, and can be done frequently without ruining
performance.</p><div class="figure"><a id="img-post-refresh"></a><p class="title"><strong>Figure 20. The buffer contents have been written to a segment, which is searchable, but is not yet commited</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/elas_1105.png" alt="The buffer contents have been written to a segment, which is searchable, but is not yet commited" /></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="refresh-api"></a>refresh API<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/master/075_Inside_a_shard/40_Near_real_time.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>In Elasticsearch, this lightweight process of writing and opening a new
segment is called a <span class="emphasis"><em>refresh</em></span>.<a id="id-1.4.13.8.9.2.2" class="indexterm"></a>
<a id="id-1.4.13.8.9.2.3" class="indexterm"></a><a id="id-1.4.13.8.9.2.4" class="indexterm"></a> By default, every shard is refreshed
automatically once every second. This is why we say that Elasticsearch has
<span class="emphasis"><em>near</em></span> real-time search: document changes are not visible to search
immediately, but will become visible within 1 second.</p><p>This can be confusing for new users: they index a document and try to search
for it, and it just isn’t there.  The way around this is to perform a manual
refresh, with the <code class="literal">refresh</code> API:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">POST /_refresh <a id="CO37-1"></a><i xmlns="" class="conum" data-value="1"></i>
POST /blogs/_refresh <a id="CO37-2"></a><i xmlns="" class="conum" data-value="2"></i></pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO37-1"><i xmlns="" class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
Refresh all indices.
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO37-2"><i xmlns="" class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>
Refresh just the <code class="literal">blogs</code> index.
</p></td></tr></table></div><div xmlns="" class="tip admon"><div class="icon"><img alt="Tip" src="images/icons/tip.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">While a refresh is much lighter than a commit, it still has a performance
cost.<a id="id-1.4.13.8.9.6.1.1" class="indexterm"></a>
<a id="id-1.4.13.8.9.6.1.2" class="indexterm"></a>  A manual refresh can be useful when writing tests, but don’t do a
manual refresh every time you index a document in production; it will hurt
your performance.  Instead, your application needs to be aware of the near
real-time nature of Elasticsearch and make allowances for it.</p></div></div><p>Not all use cases require a refresh every second.  Perhaps you are using
Elasticsearch to index millions of log files, and you would prefer to optimize
for index speed rather than near real-time search.  You can reduce the
frequency of refreshes on a per-index basis by <a id="id-1.4.13.8.9.7.1" class="indexterm"></a>setting the <code class="literal">refresh_interval</code>:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">PUT /my_logs
{
  "settings": {
    "refresh_interval": "30s" <a id="CO38-1"></a><i xmlns="" class="conum" data-value="1"></i>
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO38-1"><i xmlns="" class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
Refresh the <code class="literal">my_logs</code> index every 30 seconds.
</p></td></tr></table></div><p>The <code class="literal">refresh_interval</code> can be updated dynamically on an existing index.  You
can turn off automatic refreshes while you are building a big new index, and then turn them back on when you start using the index in production:</p><div xmlns="" class="pre_wrapper lang-json"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-json">PUT /my_logs/_settings
{ "refresh_interval": -1 } <a id="CO39-1"></a><i xmlns="" class="conum" data-value="1"></i>

PUT /my_logs/_settings
{ "refresh_interval": "1s" } <a id="CO39-2"></a><i xmlns="" class="conum" data-value="2"></i></pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO39-1"><i xmlns="" class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
Disable automatic refreshes.
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO39-2"><i xmlns="" class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>
Refresh automatically every second.
</p></td></tr></table></div><div xmlns="" class="caution admon"><div class="icon"><img alt="Caution" src="images/icons/caution.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">The <code class="literal">refresh_interval</code> expects a <span class="emphasis"><em>duration</em></span> such as <code class="literal">1s</code> (1
second) or <code class="literal">2m</code> (2 minutes).  An absolute number like <code class="literal">1</code> means
<span class="emphasis"><em>1 millisecond</em></span>--a sure way to bring your cluster to its knees.</p></div></div></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="dynamic-indices.html">
              « 
              Dynamically Updatable Indices</a>
           
        </span><span class="next">
           
          <a href="translog.html">Making Changes Persistent
               »
            </a></span></div></body></html>