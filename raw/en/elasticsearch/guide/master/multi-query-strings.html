<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Multiple Query Strings
        | Elasticsearch: The Definitive Guide [master]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [master]" /><link rel="up" href="multi-field-search.html" title="Multifield Search" /><link rel="prev" href="multi-field-search.html" title="Multifield Search" /><link rel="next" href="_single_query_string.html" title="Single Query String" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/master" /><meta xmlns="" name="DC.subject" content="Elasticsearch" /><meta xmlns="" name="DC.identifier" content="master" /><meta xmlns="" name="robots" content="noindex,nofollow" /></head><body><div xmlns="" class="page_header">This information may not apply to the latest version of Elasticsearch.
For the most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [master]
    </a></span> » <span class="breadcrumb-link"><a href="search-in-depth.html">Search in Depth</a></span> » <span class="breadcrumb-link"><a href="multi-field-search.html">Multifield Search</a></span> » <span class="breadcrumb-node">Multiple Query Strings</span></div><div xmlns="" class="navheader"><span class="prev"><a href="multi-field-search.html">
              « 
              Multifield Search</a>
           
        </span><span class="next">
           
          <a href="_single_query_string.html">Single Query String
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="multi-query-strings"></a>Multiple Query Strings<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/master/110_Multi_Field_Search/05_Multiple_query_strings.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>The simplest multifield query to deal with is the <a id="id-1.5.5.5.2.1" class="indexterm"></a>
<a id="id-1.5.5.5.2.2" class="indexterm"></a>one where we can <span class="emphasis"><em>map
search terms to specific fields</em></span>. If we know that <span class="emphasis"><em>War and Peace</em></span> is the
title, and Leo Tolstoy is the author, it is easy to write each of these
conditions as a <code class="literal">match</code> clause <a id="id-1.5.5.5.2.6" class="indexterm"></a><a id="id-1.5.5.5.2.7" class="indexterm"></a>
<a id="id-1.5.5.5.2.8" class="indexterm"></a>and to combine them with a <a class="link" href="bool-query.html" title="Combining Queries"><code class="literal">bool</code> query</a>:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "match": { "title":  "War and Peace" }},
        { "match": { "author": "Leo Tolstoy"   }}
      ]
    }
  }
}</pre></div><div xmlns="" class="sense_widget" data-snippet="snippets/110_Multi_Field_Search/05_Multiple_query_strings.json"></div><p>The <code class="literal">bool</code> query takes a <span class="emphasis"><em>more-matches-is-better</em></span> approach, so the score from
each <code class="literal">match</code> clause will be added together to provide the final <code class="literal">_score</code> for
each document. Documents that match both clauses will score higher than
documents that match just one clause.</p><p>Of course, you’re not restricted to using just <code class="literal">match</code> clauses: the <code class="literal">bool</code>
query can wrap any other query type, <a id="id-1.5.5.5.6.3" class="indexterm"></a>
<a id="id-1.5.5.5.6.4" class="indexterm"></a>including other <code class="literal">bool</code> queries.  We could
add a clause to specify that we prefer to see versions of the book that have
been translated by specific translators:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "match": { "title":  "War and Peace" }},
        { "match": { "author": "Leo Tolstoy"   }},
        { "bool":  {
          "should": [
            { "match": { "translator": "Constance Garnett" }},
            { "match": { "translator": "Louise Maude"      }}
          ]
        }}
      ]
    }
  }
}</pre></div><div xmlns="" class="sense_widget" data-snippet="snippets/110_Multi_Field_Search/05_Multiple_query_strings.json"></div><p>Why did we put the translator clauses inside a separate <code class="literal">bool</code> query?  All four
<code class="literal">match</code> queries are <code class="literal">should</code> clauses, so why didn’t we just put the translator
clauses at the same level as the title and author clauses?</p><p>The answer lies in how the score is calculated.<a id="id-1.5.5.5.10.1" class="indexterm"></a>
<a id="id-1.5.5.5.10.2" class="indexterm"></a>  The <code class="literal">bool</code> query runs each
<code class="literal">match</code> query, adds their scores together, then multiplies by the number of
matching clauses, and divides by the total number of clauses. Each clause at
the same level has the same weight. In the preceding query, the <code class="literal">bool</code> query
containing the translator clauses counts for one-third of the total score. If we had
put the translator clauses at the same level as title and author, they
would have reduced the contribution of the title and author clauses to one-quarter each.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="prioritising-clauses"></a>Prioritizing Clauses<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/master/110_Multi_Field_Search/05_Multiple_query_strings.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>It is likely that an even one-third split between clauses is not what we need for
the preceding query. <a id="id-1.5.5.5.11.2.1" class="indexterm"></a>
<a id="id-1.5.5.5.11.2.2" class="indexterm"></a>
<a id="id-1.5.5.5.11.2.3" class="indexterm"></a><a id="id-1.5.5.5.11.2.4" class="indexterm"></a>
<a id="id-1.5.5.5.11.2.5" class="indexterm"></a> Probably we’re more interested in the title and author
clauses than we are in the translator clauses. We need to tune the query to
make the title and author clauses relatively more important.</p><p>The simplest weapon in our tuning arsenal is the <code class="literal">boost</code> parameter. To
increase the weight of the <code class="literal">title</code> and <code class="literal">author</code> fields, give <a id="id-1.5.5.5.11.3.4" class="indexterm"></a>
<a id="id-1.5.5.5.11.3.5" class="indexterm"></a><a id="id-1.5.5.5.11.3.6" class="indexterm"></a>
<a id="id-1.5.5.5.11.3.7" class="indexterm"></a>them a <code class="literal">boost</code>
value higher than <code class="literal">1</code>:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "match": { <a id="CO66-1"></a><i xmlns="" class="conum" data-value="1"></i>
            "title":  {
              "query": "War and Peace",
              "boost": 2
        }}},
        { "match": { <a id="CO66-2"></a><i xmlns="" class="conum" data-value="2"></i>
            "author":  {
              "query": "Leo Tolstoy",
              "boost": 2
        }}},
        { "bool":  { <a id="CO66-3"></a><i xmlns="" class="conum" data-value="3"></i>
            "should": [
              { "match": { "translator": "Constance Garnett" }},
              { "match": { "translator": "Louise Maude"      }}
            ]
        }}
      ]
    }
  }
}</pre></div><div xmlns="" class="sense_widget" data-snippet="snippets/110_Multi_Field_Search/05_Multiple_query_strings.json"></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO66-1"><i xmlns="" class="conum" data-value="1"></i></a> <a href="#CO66-2"><i xmlns="" class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>
The <code class="literal">title</code> and <code class="literal">author</code> clauses have a <code class="literal">boost</code> value of <code class="literal">2</code>.
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO66-3"><i xmlns="" class="conum" data-value="3"></i></a> </p></td><td valign="top" align="left"><p>
The nested <code class="literal">bool</code> clause has the default <code class="literal">boost</code> of <code class="literal">1</code>.
</p></td></tr></table></div><p>The “best” value for the <code class="literal">boost</code> parameter is most easily determined by
trial and error: set a <code class="literal">boost</code> value, run test queries, repeat. A reasonable
range for <code class="literal">boost</code> lies between <code class="literal">1</code> and <code class="literal">10</code>, maybe <code class="literal">15</code>. Boosts higher than
that have little more impact because scores are
<a class="link" href="_boosting_query_clauses.html#boost-normalization" title="Note">normalized</a>.</p></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="multi-field-search.html">
              « 
              Multifield Search</a>
           
        </span><span class="next">
           
          <a href="_single_query_string.html">Single Query String
               »
            </a></span></div></body></html>