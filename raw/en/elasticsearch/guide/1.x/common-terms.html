<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Divide and Conquer
        | Elasticsearch: The Definitive Guide [1.x]
      | Elastic
    </title><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [1.x]" /><link rel="up" href="stopwords.html" title="Stopwords: Performance Versus Precision" /><link rel="prev" href="stopwords-performance.html" title="Stopwords and Performance" /><link rel="next" href="stopwords-phrases.html" title="Stopwords and Phrase Queries" /><meta name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/1.x" /><meta name="DC.subject" content="Elasticsearch" /><meta name="DC.identifier" content="1.x" /><meta name="robots" content="noindex,nofollow" /></head><body><div class="page_header">This information applies to version 1.x of Elasticsearch. For the
most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [1.x]
    </a></span> » <span class="breadcrumb-link"><a href="languages.html">Dealing with Human Language</a></span> » <span class="breadcrumb-link"><a href="stopwords.html">Stopwords: Performance Versus Precision</a></span> » <span class="breadcrumb-node">Divide and Conquer</span></div><div class="navheader"><span class="prev"><a href="stopwords-performance.html">
              « 
              Stopwords and Performance</a>
           
        </span><span class="next">
           
          <a href="stopwords-phrases.html">Stopwords and Phrase Queries
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="common-terms"></a>Divide and Conquer<a href="https://github.com/elastic/elasticsearch-definitive-guide/edit/1.x/240_Stopwords/40_Divide_and_conquer.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>The terms in a query string can be divided into more-important (low-frequency)
and less-important (high-frequency) terms.<a id="id-1.6.7.14.2.1" class="indexterm"></a>
<a id="id-1.6.7.14.2.2" class="indexterm"></a> Documents that match only the less
important terms are probably of very little interest.  Really, we want
documents that match as many of the more important terms as possible.</p><p>The <code class="literal">match</code> query accepts <a id="id-1.6.7.14.3.2" class="indexterm"></a><a id="id-1.6.7.14.3.3" class="indexterm"></a>
<a id="id-1.6.7.14.3.4" class="indexterm"></a>a <code class="literal">cutoff_frequency</code> parameter, which allows it to
divide the terms in the query string into a low-frequency and high-frequency
group.<a id="id-1.6.7.14.3.6" class="indexterm"></a>
<a id="id-1.6.7.14.3.7" class="indexterm"></a> The low-frequency group (more-important terms) form the bulk of the
query, while the high-frequency group (less-important terms) is used only for
scoring, not for matching. By treating these two groups differently, we can
gain a real boost of speed on previously slow queries.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Domain-Specific Stopwords</strong></p></div></div></div><p>One of the benefits of <code class="literal">cutoff_frequency</code> is that you get <span class="emphasis"><em>domain-specific</em></span>
stopwords for free.<a id="id-1.6.7.14.4.2.3" class="indexterm"></a><a id="id-1.6.7.14.4.2.4" class="indexterm"></a>
<a id="id-1.6.7.14.4.2.5" class="indexterm"></a> For instance, a website about movies may use the words
<span class="emphasis"><em>movie</em></span>, <span class="emphasis"><em>color</em></span>, <span class="emphasis"><em>black</em></span>, and <span class="emphasis"><em>white</em></span> so often that they could be
considered almost meaningless.  With the <code class="literal">stop</code> token filter, these domain-specific terms would have to be added to the stopwords list manually. However,
because the <code class="literal">cutoff_frequency</code> looks at the actual frequency of terms in the
index,  these words would be classified as <span class="emphasis"><em>high frequency</em></span> automatically.</p></div><p>Take this query as an example:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">{
  "match": {
    "text": {
      "query": "Quick and the dead",
      "cutoff_frequency": 0.01 <a id="CO172-1"></a><i class="conum" data-value="1"></i>
    }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO172-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>Any term that occurs in more than 1% of documents is considered to be high
frequency. The <code class="literal">cutoff_frequency</code> can be specified as a fraction (<code class="literal">0.01</code>)
or as an absolute number (<code class="literal">5</code>).</p></td></tr></table></div><p>This query uses the <code class="literal">cutoff_frequency</code> to first divide the query terms into a
low-frequency group (<code class="literal">quick</code>, <code class="literal">dead</code>) and a high-frequency group (<code class="literal">and</code>,
<code class="literal">the</code>). Then, the query is rewritten to produce the following <code class="literal">bool</code> query:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">{
  "bool": {
    "must": { <a id="CO173-1"></a><i class="conum" data-value="1"></i>
      "bool": {
        "should": [
          { "term": { "text": "quick" }},
          { "term": { "text": "dead"  }}
        ]
      }
    },
    "should": { <a id="CO173-2"></a><i class="conum" data-value="2"></i>
      "bool": {
        "should": [
          { "term": { "text": "and" }},
          { "term": { "text": "the" }}
        ]
      }
    }
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO173-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>At least one low-frequency/high-importance term <span class="emphasis"><em>must</em></span> match.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO173-2"><i class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>High-frequency/low-importance terms are entirely optional.</p></td></tr></table></div><p>The <code class="literal">must</code> clause means that at least one of the low-frequency terms—<code class="literal">quick</code> or <code class="literal">dead</code>—_must_ be present for a document to be considered a
match. All other documents are excluded.  The <code class="literal">should</code> clause then looks for
the high-frequency terms <code class="literal">and</code> and <code class="literal">the</code>,  but only in the documents collected
by the <code class="literal">must</code> clause. The sole job of the <code class="literal">should</code> clause is to score a
document like <span class="quote">“<span class="quote">Quick <span class="emphasis"><em>and the</em></span> dead</span>”</span> higher than <span class="quote">“<span class="quote"><span class="emphasis"><em>The</em></span> quick but
dead</span>”</span>.  This approach greatly reduces the number of documents that need to be
examined and scored.</p><div class="tip admon"><div class="icon"><img alt="Tip" src="images/icons/tip.png" /></div><div class="admon_content"><p>Setting the operator parameter to <code class="literal">and</code> would make <span class="emphasis"><em>all</em></span> low-frequency terms
required, and score documents that contain <span class="emphasis"><em>all</em></span> high-frequency terms higher.
However, matching documents would not be required to contain all high-frequency terms.  If you would prefer all low- and high-frequency terms to be
required, you should use a <code class="literal">bool</code> query instead.   As we saw in
<a class="xref" href="stopwords-performance.html#stopwords-and" title="and Operator">and Operator</a>, this is already an efficient query.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_controlling_precision_2"></a>Controlling Precision<a href="https://github.com/elastic/elasticsearch-definitive-guide/edit/1.x/240_Stopwords/40_Divide_and_conquer.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>The <code class="literal">minimum_should_match</code> parameter can be combined with <code class="literal">cutoff_frequency</code>
but it applies to only the low-frequency terms.<a id="id-1.6.7.14.13.2.3" class="indexterm"></a>
<a id="id-1.6.7.14.13.2.4" class="indexterm"></a>
<a id="id-1.6.7.14.13.2.5" class="indexterm"></a><a id="id-1.6.7.14.13.2.6" class="indexterm"></a>
<a id="id-1.6.7.14.13.2.7" class="indexterm"></a>  This query:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">{
  "match": {
    "text": {
      "query": "Quick and the dead",
      "cutoff_frequency": 0.01,
      "minimum_should_match": "75%"
    }
}</pre></div><p>would be rewritten as follows:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">{
  "bool": {
    "must": {
      "bool": {
        "should": [
          { "term": { "text": "quick" }},
          { "term": { "text": "dead"  }}
        ],
        "minimum_should_match": 1 <a id="CO174-1"></a><i class="conum" data-value="1"></i>
      }
    },
    "should": { <a id="CO174-2"></a><i class="conum" data-value="2"></i>
      "bool": {
        "should": [
          { "term": { "text": "and" }},
          { "term": { "text": "the" }}
        ]
      }
    }
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO174-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>Because there are only two terms, the original 75% is rounded down
to <code class="literal">1</code>, that is: <span class="emphasis"><em>one out of two low-terms must match</em></span>.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO174-2"><i class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>The high-frequency terms are still optional and used only for scoring.</p></td></tr></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_only_high_frequency_terms"></a>Only High-Frequency Terms<a href="https://github.com/elastic/elasticsearch-definitive-guide/edit/1.x/240_Stopwords/40_Divide_and_conquer.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>An <code class="literal">or</code> query for high-frequency<a id="id-1.6.7.14.14.2.2" class="indexterm"></a>
<a id="id-1.6.7.14.14.2.3" class="indexterm"></a>
<a id="id-1.6.7.14.14.2.4" class="indexterm"></a> terms only—`<span class="quote">“<span class="quote">To be, or not to be</span>”</span>'—is
the worst case for performance. It is pointless to score <span class="emphasis"><em>all</em></span> the
documents that contain only one of these terms in order to return just the top
10 matches. We are really interested only in documents in which the terms all occur
together, so in the case where there are no low-frequency terms, the query is
rewritten to make all high-frequency terms required:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">{
  "bool": {
    "must": [
      { "term": { "text": "to" }},
      { "term": { "text": "be" }},
      { "term": { "text": "or" }},
      { "term": { "text": "not" }},
      { "term": { "text": "to" }},
      { "term": { "text": "be" }}
    ]
  }
}</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_more_control_with_common_terms"></a>More Control with Common Terms<a href="https://github.com/elastic/elasticsearch-definitive-guide/edit/1.x/240_Stopwords/40_Divide_and_conquer.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>While the high/low frequency functionality in the <code class="literal">match</code> query is useful,
sometimes you want more control<a id="id-1.6.7.14.15.2.2" class="indexterm"></a>
<a id="id-1.6.7.14.15.2.3" class="indexterm"></a>
<a id="id-1.6.7.14.15.2.4" class="indexterm"></a> over how the high- and low-frequency groups
should be handled.  The <code class="literal">match</code> query exposes a subset of the
functionality available in the <code class="literal">common</code> terms query.<a id="id-1.6.7.14.15.2.7" class="indexterm"></a></p><p>For instance, we could make all low-frequency terms required, and score only
documents that have 75% of all high-frequency terms with a query like this:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">{
  "common": {
    "text": {
      "query":                  "Quick and the dead",
      "cutoff_frequency":       0.01,
      "low_freq_operator":      "and",
      "minimum_should_match": {
        "high_freq":            "75%"
      }
    }
  }
}</pre></div><p>See the <a class="ulink" href="/guide/en/elasticsearch/reference/1.7/query-dsl-common-terms-query.html" target="_top"><code class="literal">common</code> terms query</a> reference page for more options.</p></div></div><div class="navfooter"><span class="prev"><a href="stopwords-performance.html">
              « 
              Stopwords and Performance</a>
           
        </span><span class="next">
           
          <a href="stopwords-phrases.html">Stopwords and Phrase Queries
               »
            </a></span></div></body></html>
