<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Shared Index
        | Elasticsearch: The Definitive Guide [1.x]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [1.x]" /><link rel="up" href="scale.html" title="Designing for Scale" /><link rel="prev" href="user-based.html" title="User-Based Data" /><link rel="next" href="faking-it.html" title="Faking Index per User with Aliases" /><meta name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/1.x" /><meta name="DC.subject" content="Elasticsearch" /><meta name="DC.identifier" content="1.x" /><meta name="robots" content="noindex,nofollow" /></head><body><div class="page_header">This information applies to version 1.x of Elasticsearch. For the
most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [1.x]
    </a></span> » <span class="breadcrumb-link"><a href="modeling-your-data.html">Modeling Your Data</a></span> » <span class="breadcrumb-link"><a href="scale.html">Designing for Scale</a></span> » <span class="breadcrumb-node">Shared Index</span></div><div class="navheader"><span class="prev"><a href="user-based.html">
              « 
              User-Based Data</a>
           
        </span><span class="next">
           
          <a href="faking-it.html">Faking Index per User with Aliases
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="shared-index"></a>Shared Index<a href="https://github.com/elastic/elasticsearch-definitive-guide/edit/1.x/410_Scaling/65_Shared_index.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>We can use a large shared index for the many smaller <a id="id-1.9.6.17.2.1" class="indexterm"></a>
<a id="id-1.9.6.17.2.2" class="indexterm"></a><a id="id-1.9.6.17.2.3" class="indexterm"></a>
<a id="id-1.9.6.17.2.4" class="indexterm"></a>forums by indexing
the forum identifier in a field and using it as a filter:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">PUT /forums
{
  "settings": {
    "number_of_shards": 10 <a id="CO300-1"></a><i class="conum" data-value="1"></i>
  },
  "mappings": {
    "post": {
      "properties": {
        "forum_id": { <a id="CO300-2"></a><i class="conum" data-value="2"></i>
          "type":  "string",
          "index": "not_analyzed"
        }
      }
    }
  }
}

PUT /forums/post/1
{
  "forum_id": "baking", <a id="CO300-3"></a><i class="conum" data-value="3"></i>
  "title":    "Easy recipe for ginger nuts",
  ...
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO300-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
Create an index large enough to hold thousands of smaller forums.
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO300-2"><i class="conum" data-value="2"></i></a> <a href="#CO300-3"><i class="conum" data-value="3"></i></a> </p></td><td valign="top" align="left"><p>
Each post must include a <code class="literal">forum_id</code> to identify which forum it belongs
    to.
</p></td></tr></table></div><p>We can use the <code class="literal">forum_id</code> as a filter to search within a single forum.  The
filter will exclude most of the documents in the index (those from other
forums), and filter caching will ensure that responses are fast:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">GET /forums/post/_search
{
  "query": {
    "filtered": {
      "query": {
        "match": {
          "title": "ginger nuts"
        }
      },
      "filter": {
        "term": { <a id="CO301-1"></a><i class="conum" data-value="1"></i>
          "forum_id": {
            "baking"
          }
        }
      }
    }
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO301-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
The <code class="literal">term</code> filter is cached by default.
</p></td></tr></table></div><p>This approach works, but we can do better. <a id="id-1.9.6.17.8.1" class="indexterm"></a>
<a id="id-1.9.6.17.8.2" class="indexterm"></a> The posts from a single forum
would fit easily onto one shard, but currently they are scattered across all ten
shards in the index. This means that every search request has to be forwarded
to a primary or replica of all ten shards. What would be ideal is to ensure
that all the posts from a single forum are stored on the same shard.</p><p>In <a class="xref" href="routing-value.html" title="Routing a Document to a Shard">Routing a Document to a Shard</a>, we explained<a id="id-1.9.6.17.9.2" class="indexterm"></a> that a document is allocated to a
particular shard by using this formula:</p><pre class="literallayout">shard = hash(routing) % number_of_primary_shards</pre><p>The <code class="literal">routing</code> value defaults to the document’s <code class="literal">_id</code>, but we can override that
and provide our own custom routing value, such as <code class="literal">forum_id</code>.  All
documents with the same <code class="literal">routing</code> value will be stored on the same shard:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">PUT /forums/post/1?routing=baking <a id="CO302-1"></a><i class="conum" data-value="1"></i>
{
  "forum_id": "baking", <a id="CO302-2"></a><i class="conum" data-value="2"></i>
  "title":    "Easy recipe for ginger nuts",
  ...
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO302-1"><i class="conum" data-value="1"></i></a> <a href="#CO302-2"><i class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>
Using <code class="literal">forum_id</code> as the routing value ensures that all posts from the
    same forum are stored on the same shard.
</p></td></tr></table></div><p>When we search for posts in a particular forum, we can pass the same <code class="literal">routing</code>
value to ensure that the search request is run on only the single shard that
holds our documents:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">GET /forums/post/_search?routing=baking <a id="CO303-1"></a><i class="conum" data-value="1"></i>
{
  "query": {
    "filtered": {
      "query": {
        "match": {
          "title": "ginger nuts"
        }
      },
      "filter": {
        "term": { <a id="CO303-2"></a><i class="conum" data-value="2"></i>
          "forum_id": {
            "baking"
          }
        }
      }
    }
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO303-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
The query is run on only the shard that corresponds to this <code class="literal">routing</code> value.
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO303-2"><i class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>
We still need the filter, as a single shard can hold posts from many forums.
</p></td></tr></table></div><p>Multiple forums can be queried by passing a comma-separated list of <code class="literal">routing</code>
values, and including each <code class="literal">forum_id</code> in a <code class="literal">terms</code> filter:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">GET /forums/post/_search?routing=baking,cooking,recipes
{
  "query": {
    "filtered": {
      "query": {
        "match": {
          "title": "ginger nuts"
        }
      },
      "filter": {
        "terms": {
          "forum_id": {
            [ "baking", "cooking", "recipes" ]
          }
        }
      }
    }
  }
}</pre></div><p>While this approach is technically efficient, it looks a bit clumsy because of
the need to specify <code class="literal">routing</code> values and <code class="literal">terms</code> filters on every query or
indexing request.  Index aliases to the rescue!</p></div><div class="navfooter"><span class="prev"><a href="user-based.html">
              « 
              User-Based Data</a>
           
        </span><span class="next">
           
          <a href="faking-it.html">Faking Index per User with Aliases
               »
            </a></span></div></body></html>
