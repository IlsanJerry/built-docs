<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Using Language Analyzers
        | Elasticsearch: The Definitive Guide [2.x]
      | Elastic
    </title><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [2.x]" /><link rel="up" href="language-intro.html" title="Getting Started with Languages" /><link rel="prev" href="language-intro.html" title="Getting Started with Languages" /><link rel="next" href="configuring-language-analyzers.html" title="Configuring Language Analyzers" /><meta name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/2.x" /><meta name="DC.subject" content="Elasticsearch" /><meta name="DC.identifier" content="2.x" /><meta name="robots" content="noindex,nofollow" /></head><body><div class="page_header">This information applies to version 2.x of Elasticsearch. For the
most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [2.x]
    </a></span> » <span class="breadcrumb-link"><a href="languages.html">Dealing with Human Language</a></span> » <span class="breadcrumb-link"><a href="language-intro.html">Getting Started with Languages</a></span> » <span class="breadcrumb-node">Using Language Analyzers</span></div><div class="navheader"><span class="prev"><a href="language-intro.html">
              « 
              Getting Started with Languages</a>
           
        </span><span class="next">
           
          <a href="configuring-language-analyzers.html">Configuring Language Analyzers
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="using-language-analyzers"></a>Using Language Analyzers<a href="https://github.com/elastic/elasticsearch-definitive-guide/edit/2.x/200_Language_intro/10_Using.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>The built-in language analyzers are available globally and don’t need to be
configured before being used.<a id="id-1.6.3.8.2.1" class="indexterm"></a>
<a id="id-1.6.3.8.2.2" class="indexterm"></a>  They can be specified directly in the field
mapping:</p><div class="pre_wrapper lang-js"><pre class="programlisting prettyprint lang-js">PUT /my_index
{
  "mappings": {
    "blog": {
      "properties": {
        "title": {
          "type":     "string",
          "analyzer": "english" <a id="CO124-1"></a><i class="conum" data-value="1"></i>
        }
      }
    }
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO124-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
The <code class="literal">title</code> field will use the <code class="literal">english</code> analyzer instead of the default
    <code class="literal">standard</code> analyzer.
</p></td></tr></table></div><p>Of course, by passing <a id="id-1.6.3.8.5.1" class="indexterm"></a>
<a id="id-1.6.3.8.5.2" class="indexterm"></a>text through the <code class="literal">english</code> analyzer, we lose
information:</p><div class="pre_wrapper lang-js"><pre class="programlisting prettyprint lang-js">GET /my_index/_analyze?field=title <a id="CO125-1"></a><i class="conum" data-value="1"></i>
I'm not happy about the foxes</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO125-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
Emits token: <code class="literal">i'm</code>, <code class="literal">happi</code>, <code class="literal">about</code>, <code class="literal">fox</code>
</p></td></tr></table></div><p>We can’t tell if the document mentions one <code class="literal">fox</code> or many  <code class="literal">foxes</code>; the word
<code class="literal">not</code> is a stopword and is removed, so we can’t tell whether the document is
happy about foxes or not. By using the <code class="literal">english</code> analyzer, we have increased
recall as we can match more loosely, but we have reduced our ability to rank
documents accurately.</p><p>To get the best of both worlds, we can use <a class="link" href="multi-fields.html" title="String Sorting and Multifields">multifields</a> to
index the <code class="literal">title</code> field twice: once<a id="id-1.6.3.8.9.3" class="indexterm"></a>
<a id="id-1.6.3.8.9.4" class="indexterm"></a> with the <code class="literal">english</code> analyzer and once with
the <code class="literal">standard</code> analyzer:</p><div class="pre_wrapper lang-js"><pre class="programlisting prettyprint lang-js">PUT /my_index
{
  "mappings": {
    "blog": {
      "properties": {
        "title": { <a id="CO126-1"></a><i class="conum" data-value="1"></i>
          "type": "string",
          "fields": {
            "english": { <a id="CO126-2"></a><i class="conum" data-value="2"></i>
              "type":     "string",
              "analyzer": "english"
            }
          }
        }
      }
    }
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO126-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
The main <code class="literal">title</code> field uses the <code class="literal">standard</code> analyzer.
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO126-2"><i class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>
The <code class="literal">title.english</code> subfield uses the <code class="literal">english</code> analyzer.
</p></td></tr></table></div><p>With this mapping in place, we can index some test documents to demonstrate
how to use both fields at query time:</p><div class="pre_wrapper lang-js"><pre class="programlisting prettyprint lang-js">PUT /my_index/blog/1
{ "title": "I'm happy for this fox" }

PUT /my_index/blog/2
{ "title": "I'm not happy about my fox problem" }

GET /_search
{
  "query": {
    "multi_match": {
      "type":     "most_fields", <a id="CO127-1"></a><i class="conum" data-value="1"></i>
      "query":    "not happy foxes",
      "fields": [ "title", "title.english" ]
    }
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO127-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
Use the <a class="link" href="most-fields.html" title="Most Fields"><code class="literal">most_fields</code></a> query type to match the
    same text in as many fields as possible.
</p></td></tr></table></div><p>Even <a id="id-1.6.3.8.15.1" class="indexterm"></a>though neither of our documents contain the word <code class="literal">foxes</code>,  both documents
are returned as results thanks to the word stemming on the <code class="literal">title.english</code>
field.  The second document is ranked as more relevant, because the word <code class="literal">not</code>
matches on the <code class="literal">title</code> field.</p></div><div class="navfooter"><span class="prev"><a href="language-intro.html">
              « 
              Getting Started with Languages</a>
           
        </span><span class="next">
           
          <a href="configuring-language-analyzers.html">Configuring Language Analyzers
               »
            </a></span></div></body></html>
