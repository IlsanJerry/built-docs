<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Finding Parents by Their Children
        | Elasticsearch: The Definitive Guide [2.x]
      | Elastic
    </title><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [2.x]" /><link rel="up" href="parent-child.html" title="Parent-Child Relationship" /><link rel="prev" href="indexing-parent-child.html" title="Indexing Parents and Children" /><link rel="next" href="has-parent.html" title="Finding Children by Their Parents" /><meta name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/2.x" /><meta name="DC.subject" content="Elasticsearch" /><meta name="DC.identifier" content="2.x" /><meta name="robots" content="noindex,nofollow" /></head><body><div class="page_header">This information applies to version 2.x of Elasticsearch. For the
most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [2.x]
    </a></span> » <span class="breadcrumb-link"><a href="modeling-your-data.html">Modeling Your Data</a></span> » <span class="breadcrumb-link"><a href="parent-child.html">Parent-Child Relationship</a></span> » <span class="breadcrumb-node">Finding Parents by Their Children</span></div><div class="navheader"><span class="prev"><a href="indexing-parent-child.html">
              « 
              Indexing Parents and Children</a>
           
        </span><span class="next">
           
          <a href="has-parent.html">Finding Children by Their Parents
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="has-child"></a>Finding Parents by Their Children<a href="https://github.com/elastic/elasticsearch-definitive-guide/edit/2.x/404_Parent_Child/50_Has_child.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>The <code class="literal">has_child</code> query and filter can be used to find parent documents based on
the contents of their children.<a id="id-1.9.5.9.2.2" class="indexterm"></a><a id="id-1.9.5.9.2.3" class="indexterm"></a>
<a id="id-1.9.5.9.2.4" class="indexterm"></a>  For instance, we could find all branches that
have employees born after 1980 with a query like this:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">GET /company/branch/_search
{
  "query": {
    "has_child": {
      "type": "employee",
      "query": {
        "range": {
          "dob": {
            "gte": "1980-01-01"
          }
        }
      }
    }
  }
}</pre></div><p>Like the <a class="link" href="nested-query.html" title="Querying a Nested Object"><code class="literal">nested</code> query</a>, the <code class="literal">has_child</code> query could
match several child documents,<a id="id-1.9.5.9.4.3" class="indexterm"></a>
<a id="id-1.9.5.9.4.4" class="indexterm"></a> each with a different relevance
score. How these scores are reduced to a single score for the parent document
depends on the <code class="literal">score_mode</code> parameter. The default setting is <code class="literal">none</code>, which
ignores the child scores and assigns a score of <code class="literal">1.0</code> to the parents, but it
also accepts <code class="literal">avg</code>, <code class="literal">min</code>, <code class="literal">max</code>, and <code class="literal">sum</code>.</p><p>The following query will return both <code class="literal">london</code> and <code class="literal">liverpool</code>, but <code class="literal">london</code>
will get a better score because <code class="literal">Alice Smith</code> is a better match than
<code class="literal">Barry Smith</code>:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">GET /company/branch/_search
{
  "query": {
    "has_child": {
      "type":       "employee",
      "score_mode": "max",
      "query": {
        "match": {
          "name": "Alice Smith"
        }
      }
    }
  }
}</pre></div><div class="tip admon"><div class="icon"><img alt="Tip" src="images/icons/tip.png" /></div><div class="admon_content"><p>The default <code class="literal">score_mode</code> of <code class="literal">none</code> is significantly faster than the other
modes because Elasticsearch doesn’t need to calculate the score for each child
document. Set it to <code class="literal">avg</code>, <code class="literal">min</code>, <code class="literal">max</code>, or <code class="literal">sum</code> only if you care about the
score.<a id="id-1.9.5.9.7.1.7" class="indexterm"></a>
<a id="id-1.9.5.9.7.1.8" class="indexterm"></a>
<a id="id-1.9.5.9.7.1.9" class="indexterm"></a></p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="min-max-children"></a>min_children and max_children<a href="https://github.com/elastic/elasticsearch-definitive-guide/edit/2.x/404_Parent_Child/50_Has_child.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>The <code class="literal">has_child</code> query and filter both accept the <code class="literal">min_children</code> and
<code class="literal">max_children</code> parameters,<a id="id-1.9.5.9.8.2.4" class="indexterm"></a><a id="id-1.9.5.9.8.2.5" class="indexterm"></a><a id="id-1.9.5.9.8.2.6" class="indexterm"></a>
<a id="id-1.9.5.9.8.2.7" class="indexterm"></a> which will return the parent document only if the
number of matching children is within the specified range.</p><p>This query will match only branches that have at least two employees:</p><div class="pre_wrapper lang-json"><pre class="programlisting prettyprint lang-json">GET /company/branch/_search
{
  "query": {
    "has_child": {
      "type":         "employee",
      "min_children": 2, <a id="CO281-1"></a><i class="conum" data-value="1"></i>
      "query": {
        "match_all": {}
      }
    }
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO281-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
A branch must have at least two employees in order to match.
</p></td></tr></table></div><p>The performance of a <code class="literal">has_child</code> query or filter with the <code class="literal">min_children</code> or
<code class="literal">max_children</code> parameters is much the same as a <code class="literal">has_child</code> query with scoring
enabled.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>has_child Filter</strong></p></div></div></div><p>The <code class="literal">has_child</code> filter works<a id="id-1.9.5.9.8.7.2.2" class="indexterm"></a>
<a id="id-1.9.5.9.8.7.2.3" class="indexterm"></a> in the same way as the <code class="literal">has_child</code> query, except
that it doesn’t support the <code class="literal">score_mode</code> parameter. It can be used only in
<span class="emphasis"><em>filter context</em></span>—such as inside a <code class="literal">filtered</code> query—and behaves
like any other filter: it includes or excludes, but doesn’t score.</p><p>While the results of a <code class="literal">has_child</code> filter are not cached, the usual caching
rules apply to the filter <span class="emphasis"><em>inside</em></span> the <code class="literal">has_child</code> filter.</p></div></div></div><div class="navfooter"><span class="prev"><a href="indexing-parent-child.html">
              « 
              Indexing Parents and Children</a>
           
        </span><span class="next">
           
          <a href="has-parent.html">Finding Children by Their Parents
               »
            </a></span></div></body></html>
