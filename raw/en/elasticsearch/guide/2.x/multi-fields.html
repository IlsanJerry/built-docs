<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">String Sorting and Multifields
        | Elasticsearch: The Definitive Guide [2.x]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [2.x]" /><link rel="up" href="sorting.html" title="Sorting and Relevance" /><link rel="prev" href="_sorting.html" title="Sorting" /><link rel="next" href="relevance-intro.html" title="What Is Relevance?" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/2.x" /><meta xmlns="" name="DC.subject" content="Elasticsearch" /><meta xmlns="" name="DC.identifier" content="2.x" /><meta xmlns="" name="robots" content="noindex,nofollow" /></head><body><div xmlns="" class="page_header">This information applies to version 2.x of Elasticsearch. For the
most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [2.x]
    </a></span> » <span class="breadcrumb-link"><a href="getting-started.html">Getting Started</a></span> » <span class="breadcrumb-link"><a href="sorting.html">Sorting and Relevance</a></span> » <span class="breadcrumb-node">String Sorting and Multifields</span></div><div xmlns="" class="navheader"><span class="prev"><a href="_sorting.html">
              « 
              Sorting</a>
           
        </span><span class="next">
           
          <a href="relevance-intro.html">What Is Relevance?
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="multi-fields"></a>String Sorting and Multifields<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/2.x/056_Sorting/88_String_sorting.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>Analyzed string fields are also multivalue fields,<a id="id-1.4.10.4.2.1" class="indexterm"></a>
<a id="id-1.4.10.4.2.2" class="indexterm"></a><a id="id-1.4.10.4.2.3" class="indexterm"></a>
<a id="id-1.4.10.4.2.4" class="indexterm"></a><a id="id-1.4.10.4.2.5" class="indexterm"></a>
<a id="id-1.4.10.4.2.6" class="indexterm"></a> but sorting on them seldom
gives you the results you want. If you analyze a string like <code class="literal">fine old art</code>,
it results in three terms. We probably want to sort alphabetically on the
first term, then the second term, and so forth, but Elasticsearch doesn’t have this
information at its disposal at sort time.</p><p>You could use the <code class="literal">min</code> and <code class="literal">max</code> sort modes (it uses <code class="literal">min</code> by default), but
that will result in sorting on either <code class="literal">art</code> or <code class="literal">old</code>, neither of which was the
intent.</p><p>In order to sort on a string field, that field should contain one term only:
the whole <code class="literal">not_analyzed</code> string.<a id="id-1.4.10.4.4.2" class="indexterm"></a>
<a id="id-1.4.10.4.4.3" class="indexterm"></a>  But of course we still need the field to be
<code class="literal">analyzed</code> in order to be able to query it as full text.</p><p>The naive approach to indexing the same string in two ways would be to include
two separate fields in the document: one that is  <code class="literal">analyzed</code> for searching,
and one that is <code class="literal">not_analyzed</code> for sorting.</p><p>But  storing the same string twice in the <code class="literal">_source</code> field is waste of space.
What we really want to do is to pass in a <span class="emphasis"><em>single field</em></span> but to <span class="emphasis"><em>index it in two different ways</em></span>. All of the <span class="emphasis"><em>core</em></span> field types (strings, numbers,
Booleans, dates) accept a <code class="literal">fields</code> parameter <a id="id-1.4.10.4.6.6" class="indexterm"></a>
<a id="id-1.4.10.4.6.7" class="indexterm"></a><a id="id-1.4.10.4.6.8" class="indexterm"></a>
<a id="id-1.4.10.4.6.9" class="indexterm"></a>
<a id="id-1.4.10.4.6.10" class="indexterm"></a><a id="id-1.4.10.4.6.11" class="indexterm"></a><a id="id-1.4.10.4.6.12" class="indexterm"></a>that allows you to transform a
simple mapping like:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">"tweet": {
    "type":     "string",
    "analyzer": "english"
}</pre></div><p>into a <span class="emphasis"><em>multifield</em></span> mapping like this:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">"tweet": { <a id="CO28-1"></a><i xmlns="" class="conum" data-value="1"></i>
    "type":     "string",
    "analyzer": "english",
    "fields": {
        "raw": { <a id="CO28-2"></a><i xmlns="" class="conum" data-value="2"></i>
            "type":  "string",
            "index": "not_analyzed"
        }
    }
}</pre></div><div xmlns="" class="sense_widget" data-snippet="snippets/056_Sorting/88_Multifield.json"></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO28-1"><i xmlns="" class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
The main <code class="literal">tweet</code> field is just the same as before: an <code class="literal">analyzed</code> full-text
    field.
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO28-2"><i xmlns="" class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>
The new <code class="literal">tweet.raw</code> subfield is <code class="literal">not_analyzed</code>.
</p></td></tr></table></div><p>Now, or at least as soon as we have reindexed our data, we can use the <code class="literal">tweet</code>
field for search and the <code class="literal">tweet.raw</code> field for sorting:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /_search
{
    "query": {
        "match": {
            "tweet": "elasticsearch"
        }
    },
    "sort": "tweet.raw"
}</pre></div><div xmlns="" class="sense_widget" data-snippet="snippets/056_Sorting/88_Multifield.json"></div><div xmlns="" class="warning admon"><div class="icon"><img alt="Warning" src="images/icons/warning.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">Sorting on a full-text <code class="literal">analyzed</code> field can use a lot of memory.  See
<a class="xref" href="aggregations-and-analysis.html" title="Aggregations and Analysis">Aggregations and Analysis</a> for more information.</p></div></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="_sorting.html">
              « 
              Sorting</a>
           
        </span><span class="next">
           
          <a href="relevance-intro.html">What Is Relevance?
               »
            </a></span></div></body></html>