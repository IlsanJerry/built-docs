<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Doc Values
        | Elasticsearch: The Definitive Guide [2.x]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [2.x]" /><link rel="up" href="docvalues-and-fielddata.html" title="Doc Values and Fielddata" /><link rel="prev" href="docvalues-and-fielddata.html" title="Doc Values and Fielddata" /><link rel="next" href="_deep_dive_on_doc_values.html" title="Deep Dive on Doc Values" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/2.x" /><meta xmlns="" name="DC.subject" content="Elasticsearch" /><meta xmlns="" name="DC.identifier" content="2.x" /><meta xmlns="" name="robots" content="noindex,nofollow" /></head><body><div xmlns="" class="page_header">This information applies to version 2.x of Elasticsearch. For the
most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [2.x]
    </a></span> » <span class="breadcrumb-link"><a href="aggregations.html">Aggregations</a></span> » <span class="breadcrumb-link"><a href="docvalues-and-fielddata.html">Doc Values and Fielddata</a></span> » <span class="breadcrumb-node">Doc Values</span></div><div xmlns="" class="navheader"><span class="prev"><a href="docvalues-and-fielddata.html">
              « 
              Doc Values and Fielddata</a>
           
        </span><span class="next">
           
          <a href="_deep_dive_on_doc_values.html">Deep Dive on Doc Values
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="docvalues"></a>Doc Values<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/2.x/300_Aggregations/90_docvalues.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>Aggregations work via a data structure known as <span class="emphasis"><em>doc values</em></span> (briefly introduced
in <a class="xref" href="docvalues-intro.html" title="Doc Values Intro">Doc Values Intro</a>).  <a id="id-1.7.12.2.2.3" class="indexterm"></a><a id="id-1.7.12.2.2.4" class="indexterm"></a>Doc values
are what make aggregations fast, efficient and memory-friendly, so it is useful
to understand how they work.</p><p>Doc values exists because inverted indices are efficient for only certain operations.
The inverted index excels<a id="id-1.7.12.2.3.1" class="indexterm"></a>
<a id="id-1.7.12.2.3.2" class="indexterm"></a> at finding documents that contain a term.  It does not
perform well in the opposite direction: determining which terms exist in a single
document. Aggregations need this secondary access pattern.</p><p>Consider the following inverted index:</p><pre class="literallayout">Term      Doc_1   Doc_2   Doc_3
------------------------------------
brown   |   X   |   X   |
dog     |   X   |       |   X
dogs    |       |   X   |   X
fox     |   X   |       |   X
foxes   |       |   X   |
in      |       |   X   |
jumped  |   X   |       |   X
lazy    |   X   |   X   |
leap    |       |   X   |
over    |   X   |   X   |   X
quick   |   X   |   X   |   X
summer  |       |   X   |
the     |   X   |       |   X
------------------------------------</pre><p>If we want to compile a complete list of terms in any document that mentions
<code class="literal">brown</code>, we might build a query like so:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /my_index/_search
{
  "query" : {
    "match" : {
      "body" : "brown"
    }
  },
  "aggs" : {
    "popular_terms": {
      "terms" : {
        "field" : "body"
      }
    }
  }
}</pre></div><p>The query portion is easy and efficient.  The inverted index is sorted by
terms, so first we find <code class="literal">brown</code> in the terms list, and then scan across all the
columns to see which documents contain <code class="literal">brown</code>.  We can very quickly see that
<code class="literal">Doc_1</code> and <code class="literal">Doc_2</code> contain the token <code class="literal">brown</code>.</p><p>Then, for the aggregation portion, we need to find all the unique terms in
<code class="literal">Doc_1</code>  and <code class="literal">Doc_2</code>.<a id="id-1.7.12.2.9.3" class="indexterm"></a>
<a id="id-1.7.12.2.9.4" class="indexterm"></a>
<a id="id-1.7.12.2.9.5" class="indexterm"></a>  Trying to do this with the inverted index would be a
very expensive process: we would have to iterate over every term in the index
and collect tokens from <code class="literal">Doc_1</code>  and <code class="literal">Doc_2</code> columns.  This would be slow
and scale poorly: as the number of terms and  documents grows, so would the
execution time.</p><p>Doc values addresses this problem by inverting the relationship. While the
inverted index maps terms to the documents containing the term, doc values
maps documents to the terms contained by the document:</p><pre class="literallayout">Doc      Terms
-----------------------------------------------------------------
Doc_1 | brown, dog, fox, jumped, lazy, over, quick, the
Doc_2 | brown, dogs, foxes, in, lazy, leap, over, quick, summer
Doc_3 | dog, dogs, fox, jumped, over, quick, the
-----------------------------------------------------------------</pre><p>Once the data has been uninverted, it is trivial to collect the unique tokens from
<code class="literal">Doc_1</code> and <code class="literal">Doc_2</code>.  Go to the rows for each document, collect all the terms, and
take the union of the two sets.</p><p>Thus, search and aggregations are closely intertwined.  Search finds documents
by using the inverted index.  Aggregations collect and aggregate values from
doc values.</p><div xmlns="" class="note admon"><div class="icon"><img alt="Note" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">Doc values are not just used for aggregations.<a id="id-1.7.12.2.14.1.1" class="indexterm"></a>
<a id="id-1.7.12.2.14.1.2" class="indexterm"></a>  They are required for any
operation that must look up the value contained in a specific document.
Besides aggregations, this includes sorting, scripts that access field
values and parent-child relationships (see <a class="xref" href="parent-child.html" title="Parent-Child Relationship"><em>Parent-Child Relationship</em></a>).</p></div></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="docvalues-and-fielddata.html">
              « 
              Doc Values and Fielddata</a>
           
        </span><span class="next">
           
          <a href="_deep_dive_on_doc_values.html">Deep Dive on Doc Values
               »
            </a></span></div></body></html>