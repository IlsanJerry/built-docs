<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Looking at Time
        | Elasticsearch: The Definitive Guide [2.x]
      | Elastic
    </title><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [2.x]" /><link rel="up" href="aggregations.html" title="Aggregations" /><link rel="prev" href="_building_bar_charts.html" title="Building Bar Charts" /><link rel="next" href="_returning_empty_buckets.html" title="Returning Empty Buckets" /><meta name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/2.x" /><meta name="DC.subject" content="Elasticsearch" /><meta name="DC.identifier" content="2.x" /><meta name="robots" content="noindex,nofollow" /></head><body><div class="page_header">This information applies to version 2.x of Elasticsearch. For the
most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [2.x]
    </a></span> » <span class="breadcrumb-link"><a href="aggregations.html">Aggregations</a></span> » <span class="breadcrumb-node">Looking at Time</span></div><div class="navheader"><span class="prev"><a href="_building_bar_charts.html">
              « 
              Building Bar Charts</a>
           
        </span><span class="next">
           
          <a href="_returning_empty_buckets.html">Returning Empty Buckets
               »
            </a></span></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_looking_at_time"></a>Looking at Time</h2></div></div></div><p>If search is the most popular activity in Elasticsearch, building date
histograms must be the second most popular.<a id="id-1.7.6.2.1" class="indexterm"></a><a id="id-1.7.6.2.2" class="indexterm"></a><a id="id-1.7.6.2.3" class="indexterm"></a>  Why would you want to use a date
histogram?</p><p>Imagine your data has a timestamp.<a id="id-1.7.6.3.1" class="indexterm"></a>  It doesn’t matter what the data is—​Apache
log events, stock buy/sell transaction dates, baseball game times—​anything with a timestamp can benefit from the date histogram.  When you have
a timestamp, you often want to build metrics that are expressed <span class="emphasis"><em>over time</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">How many cars sold each month this year?</li><li class="listitem">What was the price of this stock for the last 12 hours?</li><li class="listitem">What was the average latency of our website every hour in the last week?</li></ul></div><p>While regular histograms are often represented as bar charts, date histograms
tend to be converted into line graphs representing time series.<a id="id-1.7.6.5.1" class="indexterm"></a>  Many
companies use Elasticsearch <span class="emphasis"><em>solely</em></span> for analytics over time series data.  The <code class="literal">date_histogram</code> bucket is their bread and butter.</p><p>The <code class="literal">date_histogram</code> bucket works<a id="id-1.7.6.6.2" class="indexterm"></a> similarly to the regular <code class="literal">histogram</code>.  Rather
than building buckets based on a numeric field representing numeric ranges,
it builds buckets based on time ranges.  Each bucket is therefore defined as a
certain calendar size (for example, <code class="literal">1 month</code> or <code class="literal">2.5 days</code>).</p><div class="pagebreak-before sidebar"><div class="titlepage"><div><div><p class="title"><strong>Can a Regular Histogram Work with Dates?</strong></p></div></div></div><p>Technically, yes.<a id="id-1.7.6.7.2.1" class="indexterm"></a>  A regular <code class="literal">histogram</code> bucket will work with dates.  However,
it is not calendar-aware.  With the <code class="literal">date_histogram</code>, you can specify intervals
such as <code class="literal">1 month</code>, which knows that February is shorter than December.  The
<code class="literal">date_histogram</code> also has the advantage of being able to work with time zones,
which allows you to customize graphs to the time zone of the user, not the server.</p><p>The regular histogram will interpret dates as numbers, which means you must specify
intervals in terms of milliseconds.  And the aggregation doesn’t know about
calendar intervals, which makes it largely useless for dates.</p></div><p>Our first example <a id="id-1.7.6.8.1" class="indexterm"></a>will build a simple line chart to answer this question:
how many cars were sold each month?</p><div class="pre_wrapper lang-sense"><pre class="programlisting prettyprint lang-sense">GET /cars/transactions/_search
{
   "size" : 0,
   "aggs": {
      "sales": {
         "date_histogram": {
            "field": "sold",
            "interval": "month", <a id="CO194-1"></a><i class="conum" data-value="1"></i>
            "format": "yyyy-MM-dd" <a id="CO194-2"></a><i class="conum" data-value="2"></i>
         }
      }
   }
}</pre></div><div class="sense_widget" data-snippet="snippets/300_Aggregations/35_date_histogram.json"></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO194-1"><i class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>The interval is requested in calendar terminology (for example, one month per bucket).</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO194-2"><i class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>We provide a date format so that bucket keys are pretty.</p></td></tr></table></div><p>Our query has a single aggregation, which builds a bucket
per month.  This will give us the number of cars sold in each month.  An additional
<code class="literal">format</code> parameter is provided so the buckets have "pretty" keys.  Internally,
dates are simply represented as a numeric value.  This tends to make UI designers
grumpy, however, so a prettier format can be specified using common date formatting.</p><p>The response is both expected and a little surprising (see if you can spot
the surprise):</p><div class="pre_wrapper lang-js"><pre class="programlisting prettyprint lang-js">{
   ...
   "aggregations": {
      "sales": {
         "buckets": [
            {
               "key_as_string": "2014-01-01",
               "key": 1388534400000,
               "doc_count": 1
            },
            {
               "key_as_string": "2014-02-01",
               "key": 1391212800000,
               "doc_count": 1
            },
            {
               "key_as_string": "2014-05-01",
               "key": 1398902400000,
               "doc_count": 1
            },
            {
               "key_as_string": "2014-07-01",
               "key": 1404172800000,
               "doc_count": 1
            },
            {
               "key_as_string": "2014-08-01",
               "key": 1406851200000,
               "doc_count": 1
            },
            {
               "key_as_string": "2014-10-01",
               "key": 1412121600000,
               "doc_count": 1
            },
            {
               "key_as_string": "2014-11-01",
               "key": 1414800000000,
               "doc_count": 2
            }
         ]
...
}</pre></div><p>The aggregation is represented in full.  As you can see, we have buckets
that represent months, a count of docs in each month, and our pretty <code class="literal">key_as_string</code>.</p></div><div class="navfooter"><span class="prev"><a href="_building_bar_charts.html">
              « 
              Building Bar Charts</a>
           
        </span><span class="next">
           
          <a href="_returning_empty_buckets.html">Returning Empty Buckets
               »
            </a></span></div></body></html>
