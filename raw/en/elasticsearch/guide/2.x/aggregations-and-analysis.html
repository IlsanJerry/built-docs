<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns="">Aggregations and Analysis
        | Elasticsearch: The Definitive Guide [2.x]
      | Elastic
    </title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [2.x]" /><link rel="up" href="docvalues-and-fielddata.html" title="Doc Values and Fielddata" /><link rel="prev" href="_deep_dive_on_doc_values.html" title="Deep Dive on Doc Values" /><link rel="next" href="_limiting_memory_usage.html" title="Limiting Memory Usage" /><meta xmlns="" name="description" content="Get started with the documentation for Elasticsearch, Kibana, Logstash, Beats, X-Pack, Elastic Cloud, Elasticsearch for Apache Hadoop, and our language clients." /><meta xmlns="" name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/2.x" /><meta xmlns="" name="DC.subject" content="Elasticsearch" /><meta xmlns="" name="DC.identifier" content="2.x" /><meta xmlns="" name="robots" content="noindex,nofollow" /></head><body><div xmlns="" class="page_header">This information applies to version 2.x of Elasticsearch. For the
most up to date information, see the current version of the
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">
Elasticsearch Reference</a>.
</div><div xmlns="" class="breadcrumbs"><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide
      [2.x]
    </a></span> » <span class="breadcrumb-link"><a href="aggregations.html">Aggregations</a></span> » <span class="breadcrumb-link"><a href="docvalues-and-fielddata.html">Doc Values and Fielddata</a></span> » <span class="breadcrumb-node">Aggregations and Analysis</span></div><div xmlns="" class="navheader"><span class="prev"><a href="_deep_dive_on_doc_values.html">
              « 
              Deep Dive on Doc Values</a>
           
        </span><span class="next">
           
          <a href="_limiting_memory_usage.html">Limiting Memory Usage
               »
            </a></span></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="aggregations-and-analysis"></a>Aggregations and Analysis<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/2.x/300_Aggregations/95_analyzed_vs_not.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h2></div></div></div><p>Some aggregations, such as the <code class="literal">terms</code> bucket, operate<a id="id-1.7.12.4.2.2" class="indexterm"></a>
<a id="id-1.7.12.4.2.3" class="indexterm"></a><a id="id-1.7.12.4.2.4" class="indexterm"></a>
<a id="id-1.7.12.4.2.5" class="indexterm"></a> on string fields.  And
string fields may be either <code class="literal">analyzed</code> or <code class="literal">not_analyzed</code>, which raises the question:
how does analysis affect aggregations?<a id="id-1.7.12.4.2.8" class="indexterm"></a>
<a id="id-1.7.12.4.2.9" class="indexterm"></a><a id="id-1.7.12.4.2.10" class="indexterm"></a><a id="id-1.7.12.4.2.11" class="indexterm"></a></p><p>The answer is "a lot," for two reasons: analysis affects the tokens used in the aggregation,
and doc values <span class="emphasis"><em>do not work</em></span> with analyzed strings.</p><p>Let’s tackle the first problem: how the generation of analyzed tokens affects
aggregations. First, let’s index some documents representing various states in the US:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">POST /agg_analysis/data/_bulk
{ "index": {}}
{ "state" : "New York" }
{ "index": {}}
{ "state" : "New Jersey" }
{ "index": {}}
{ "state" : "New Mexico" }
{ "index": {}}
{ "state" : "New York" }
{ "index": {}}
{ "state" : "New York" }</pre></div><p>We want to build a list of unique states in our dataset, complete with counts.
Simple—let’s use a <code class="literal">terms</code> bucket:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">GET /agg_analysis/data/_search
{
    "size" : 0,
    "aggs" : {
        "states" : {
            "terms" : {
                "field" : "state"
            }
        }
    }
}</pre></div><p>This gives us these results:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">{
...
   "aggregations": {
      "states": {
         "buckets": [
            {
               "key": "new",
               "doc_count": 5
            },
            {
               "key": "york",
               "doc_count": 3
            },
            {
               "key": "jersey",
               "doc_count": 1
            },
            {
               "key": "mexico",
               "doc_count": 1
            }
         ]
      }
   }
}</pre></div><p>Oh dear, that’s not at all what we want!  Instead of counting states, the aggregation
is counting individual words.  The underlying reason is simple: aggregations
are built from the inverted index, and the inverted index is <span class="emphasis"><em>post-analysis</em></span>.</p><p>When we added those documents to Elasticsearch, the string <code class="literal">"New York"</code> was
analyzed/tokenized into <code class="literal">["new", "york"]</code>.  These individual tokens were then
used to populate aggregation counts, and ultimately we see counts for <code class="literal">new</code> instead of
<code class="literal">New York</code>.</p><p>This is obviously not the behavior that we wanted, but luckily it is easily
corrected.</p><p>We need to define a multifield for <code class="literal">state</code> and set it to <code class="literal">not_analyzed</code>.  This
will prevent <code class="literal">New York</code> from being analyzed, which means it will stay a single
token in the aggregation.  Let’s try the whole process over, but this time
specify a <span class="emphasis"><em>raw</em></span> multifield:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">DELETE /agg_analysis/
PUT /agg_analysis
{
  "mappings": {
    "data": {
      "properties": {
        "state" : {
          "type": "string",
          "fields": {
            "raw" : {
              "type": "string",
              "index": "not_analyzed"<a id="CO218-1"></a><i xmlns="" class="conum" data-value="1"></i>
            }
          }
        }
      }
    }
  }
}

POST /agg_analysis/data/_bulk
{ "index": {}}
{ "state" : "New York" }
{ "index": {}}
{ "state" : "New Jersey" }
{ "index": {}}
{ "state" : "New Mexico" }
{ "index": {}}
{ "state" : "New York" }
{ "index": {}}
{ "state" : "New York" }

GET /agg_analysis/data/_search
{
  "size" : 0,
  "aggs" : {
    "states" : {
        "terms" : {
            "field" : "state.raw" <a id="CO218-2"></a><i xmlns="" class="conum" data-value="2"></i>
        }
    }
  }
}</pre></div><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO218-1"><i xmlns="" class="conum" data-value="1"></i></a> </p></td><td valign="top" align="left"><p>
This time we explicitly map the <code class="literal">state</code> field and include a <code class="literal">not_analyzed</code> sub-field.
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO218-2"><i xmlns="" class="conum" data-value="2"></i></a> </p></td><td valign="top" align="left"><p>
The aggregation is run on <code class="literal">state.raw</code> instead of <code class="literal">state</code>.
</p></td></tr></table></div><p>Now when we run our aggregation, we get results that make sense:</p><div xmlns="" class="pre_wrapper lang-js"><pre xmlns="http://www.w3.org/1999/xhtml" class="programlisting prettyprint lang-js">{
...
   "aggregations": {
      "states": {
         "buckets": [
            {
               "key": "New York",
               "doc_count": 3
            },
            {
               "key": "New Jersey",
               "doc_count": 1
            },
            {
               "key": "New Mexico",
               "doc_count": 1
            }
         ]
      }
   }
}</pre></div><p>In practice, this kind of problem is easy to spot.  Your aggregations
will simply return strange buckets, and you’ll remember the analysis issue.
It is a generalization, but there are not many instances where you want to use
an analyzed  field in an aggregation.  When in doubt, add a multifield so
you have the option for both.<a id="id-1.7.12.4.18.1" class="indexterm"></a>
<a id="id-1.7.12.4.18.2" class="indexterm"></a></p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_analyzed_strings_and_fielddata"></a>Analyzed strings and Fielddata<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/2.x/300_Aggregations/95_analyzed_vs_not.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>While the first problem relates to how data is aggregated and displayed to your
user, the second problem is largely technical and behind the scenes.</p><p>Doc values do not support <code class="literal">analyzed</code> string fields because they are not very efficient
at representing multi-valued strings.  Doc values are most efficient
when each document has one or several tokens, but not thousands as in the case
of large, analyzed strings (imagine a PDF body, which may be several megabytes
and have thousands of unique tokens).</p><p>For that reason, doc values are not generated for <code class="literal">analyzed</code> strings.  Yet these fields
can still be used in aggregations.  How is that possible?</p><p>The answer is a data structure known as <span class="emphasis"><em>fielddata</em></span>.  Unlike doc values, fielddata
is built and managed 100% in memory, living inside the JVM heap.  That means
it is inherently less scalable and has a lot of edge-cases to watch out for.
The rest of this chapter are addressing the challenges of fielddata in the context
of <code class="literal">analyzed</code> strings</p><div xmlns="" class="note admon"><div class="icon"><img alt="Note" src="images/icons/note.png" /></div><div class="admon_content"><p xmlns="http://www.w3.org/1999/xhtml">Historically, fielddata was the default for <span class="emphasis"><em>all</em></span> fields, but Elasticsearch
has been migrating towards doc values to reduce the chance of OOM.
Analyzed strings are the last holdout where fielddata is still used.  The goal is to
eventually build a serialized data structure similar to doc values which can handle
highly dimensional analyzed strings, obsoleting fielddata once and for all.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_high_cardinality_memory_implications"></a>High-Cardinality Memory Implications<a xmlns="" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/2.x/300_Aggregations/95_analyzed_vs_not.asciidoc" class="edit_me" title="Edit this page on GitHub" rel="nofollow">edit</a></h3></div></div></div><p>There is another reason to avoid aggregating analyzed fields: high-cardinality
fields consume a large amount of memory when loaded into fielddata.<a id="id-1.7.12.4.20.2.1" class="indexterm"></a>
<a id="id-1.7.12.4.20.2.2" class="indexterm"></a><a id="id-1.7.12.4.20.2.3" class="indexterm"></a>
<a id="id-1.7.12.4.20.2.4" class="indexterm"></a>  The
analysis process often (although not always) generates a large number of tokens,
many of  which are unique.  This increases the overall cardinality of the field
and contributes to more memory pressure.<a id="id-1.7.12.4.20.2.5" class="indexterm"></a>
<a id="id-1.7.12.4.20.2.6" class="indexterm"></a></p><p>Some types of analysis are <span class="emphasis"><em>extremely</em></span> unfriendly with regards to memory.
Consider an n-gram analysis process.<a id="id-1.7.12.4.20.3.2" class="indexterm"></a>
<a id="id-1.7.12.4.20.3.3" class="indexterm"></a>  The term <code class="literal">New York</code> might be n-grammed into
the following tokens:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
<code class="literal">ne</code>
</li><li class="listitem">
<code class="literal">ew</code>
</li><li class="listitem">
<code class="literal">w </code>
</li><li class="listitem">
<code class="literal"> y</code>
</li><li class="listitem">
<code class="literal">yo</code>
</li><li class="listitem">
<code class="literal">or</code>
</li><li class="listitem">
<code class="literal">rk</code>
</li></ul></div><p>You can imagine how the n-gramming process creates a huge number of unique tokens,
especially when analyzing paragraphs of text.  When these are loaded into memory,
you can easily exhaust your heap space.</p><p>So, before aggregating string fields, assess the situation:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
Is it a <code class="literal">not_analyzed</code> field?  If yes, the field will use doc values and be memory-friendly
</li><li class="listitem">
Otherwise, this is an <code class="literal">analyzed</code> field.  It will use fielddata and live in-memory.
Does this field have a very large cardinality caused by ngrams, shingles, etc? If yes,
it may be very memory unfriendly.
</li></ul></div></div></div><div xmlns="" class="navfooter"><span class="prev"><a href="_deep_dive_on_doc_values.html">
              « 
              Deep Dive on Doc Values</a>
           
        </span><span class="next">
           
          <a href="_limiting_memory_usage.html">Limiting Memory Usage
               »
            </a></span></div></body></html>